{
  "folderName": "osmocli",
  "folderPath": ".autodoc/docs/json/osmoutils/osmocli",
  "url": "https://github.com/duality-labs/duality/utodoc/docs/json/osmoutils/osmocli",
  "files": [
    {
      "fileName": "flag_advice.go",
      "filePath": "osmoutils/osmocli/flag_advice.go",
      "url": "https://github.com/duality-labs/duality/osmoutils/osmocli/flag_advice.go",
      "summary": "The `osmocli` package contains code that provides a command-line interface (CLI) for interacting with the Osmocom cellular network stack. The code in this file defines several types and functions that are used to parse and handle command-line flags.\n\nThe `FlagAdvice` type is a struct that contains advice on how to handle command-line flags. It has several fields that are used to customize the behavior of the CLI. For example, the `HasPagination` field is a boolean that indicates whether the CLI should paginate its output. The `CustomFlagOverrides` field is a map that allows users to override the default flag names with custom names. The `CustomFieldParsers` field is a map that allows users to define custom parsers for command-line flags.\n\nThe `FlagDesc` type is a struct that describes the flags that should be added to a command. It has two fields: `RequiredFlags` and `OptionalFlags`. These fields are arrays of `pflag.FlagSet` objects, which represent sets of command-line flags.\n\nThe `AddFlags` function takes a `cobra.Command` object and a `FlagDesc` object as arguments. It adds the flags described in the `FlagDesc` object to the `cobra.Command` object. If a flag is marked as required, the function also marks it as required in the `cobra.Command` object.\n\nThe `Sanitize` method is a method on the `FlagAdvice` type that sanitizes the `CustomFlagOverrides` and `CustomFieldParsers` fields. It converts all keys to lowercase and initializes the fields if they are uninitialized.\n\nThe `FlagOnlyParser` function is a function that takes a function that returns a value of any type and returns a `CustomFieldParserFn`. This function is used to create custom parsers for command-line flags.\n\nOverall, this code provides a flexible and extensible way to handle command-line flags in the Osmocom CLI. It allows users to customize the behavior of the CLI by defining custom flag names and parsers. It also provides a way to mark flags as required, which helps ensure that users provide all necessary input.",
      "questions": "1. What is the purpose of the `FlagAdvice` struct and its fields?\n- The `FlagAdvice` struct contains fields that provide advice on how to handle flags for a command, including whether pagination is needed, custom flag overrides, custom field parsers, and transaction sender information.\n\n2. What is the purpose of the `AddFlags` function?\n- The `AddFlags` function adds flag sets to a given `cobra.Command` instance, marking required flags as required.\n\n3. What is the purpose of the `Sanitize` method on the `FlagAdvice` struct?\n- The `Sanitize` method maps the keys of `CustomFlagOverrides` and `CustomFieldParsers` to lowercase and initializes them if they are uninitialized."
    },
    {
      "fileName": "index_cmd.go",
      "filePath": "osmoutils/osmocli/index_cmd.go",
      "url": "https://github.com/duality-labs/duality/osmoutils/osmocli/index_cmd.go",
      "summary": "The `osmocli` package contains code for a command-line interface (CLI) tool that interacts with an Osmocom cellular network. This specific file contains two functions: `IndexCmd` and `indexRunCmd`.\n\nThe `IndexCmd` function takes in a `moduleName` string and returns a `cobra.Command` object. This object represents a CLI command that can be executed by the user. The `Use` field of the command is set to the `moduleName` parameter, which is the name of the module being queried. The `Short` field is set to a formatted string that describes the purpose of the command. The `DisableFlagParsing` field is set to `true`, which means that any flags passed to the command will not be parsed. The `SuggestionsMinimumDistance` field is set to `2`, which means that the CLI will suggest commands that are at most two characters different from the user's input. Finally, the `RunE` field is set to the `indexRunCmd` function, which will be executed when the command is run.\n\nThe `indexRunCmd` function takes in a `cobra.Command` object and a slice of strings as arguments. It sets a custom usage template for the command using the `SetUsageTemplate` method of the `cmd` object. The template is a string that defines how the command's usage information will be displayed to the user. The function then calls the `Help` method of the `cmd` object, which prints the usage information to the console.\n\nOverall, this code defines a CLI command that can be used to query information about a specific module in an Osmocom cellular network. The `IndexCmd` function creates the command object, and the `indexRunCmd` function sets a custom usage template and prints the usage information to the console. This code can be used as a building block for a larger CLI tool that interacts with an Osmocom network. An example of how this code might be used is shown below:\n\n```\npackage main\n\nimport (\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/osmocom/duality/osmocli\"\n)\n\nfunc main() {\n\trootCmd := &cobra.Command{\n\t\tUse: \"duality\",\n\t}\n\n\tmoduleCmd := osmocli.IndexCmd(\"module_name\")\n\trootCmd.AddCommand(moduleCmd)\n\n\tif err := rootCmd.Execute(); err != nil {\n\t\tos.Exit(1)\n\t}\n}\n```\n\nIn this example, a root command is created with the name \"duality\". The `IndexCmd` function is called with the parameter \"module_name\", which creates a CLI command that can be used to query information about the \"module_name\" module. The `moduleCmd` object is added as a subcommand of the root command using the `AddCommand` method. Finally, the `Execute` method is called on the root command, which runs the CLI tool and waits for user input. When the user enters the `module_name` command, the `indexRunCmd` function is executed, which prints the usage information to the console.",
      "questions": "1. What is the purpose of the `IndexCmd` function?\n- The `IndexCmd` function returns a `cobra.Command` that is used to query commands for a specific module.\n\n2. What is the significance of `DisableFlagParsing` being set to true?\n- Setting `DisableFlagParsing` to true disables the parsing of flags for the command, which means that any flags passed to the command will be ignored.\n\n3. What is the purpose of the `usageTemplate` variable in the `indexRunCmd` function?\n- The `usageTemplate` variable is a string that defines the usage template for the command. It is used to generate the usage message that is displayed when the `--help` flag is passed to the command."
    },
    {
      "fileName": "parsers.go",
      "filePath": "osmoutils/osmocli/parsers.go",
      "url": "https://github.com/duality-labs/duality/osmoutils/osmocli/parsers.go",
      "summary": "The code in this file is part of the `osmocli` package and provides functionality for parsing command-line arguments and flags for the duality project. It uses reflection to dynamically parse the fields of a given struct based on the provided arguments and flags.\n\nThe main function, `ParseFieldsFromFlagsAndArgs`, takes a `FlagAdvice` struct, a `pflag.FlagSet`, and a slice of arguments. It iterates over the fields of the struct and calls `ParseField` to parse each field either from an argument or a flag. The parsed values are then set on the struct, and the function returns the populated struct.\n\nThe `ParseField` function checks if there is a custom parser for the field in the `FlagAdvice` struct. If so, it uses the custom parser to parse the field. Otherwise, it tries to parse the field from a flag using `ParseFieldFromFlag`. If the field is not parsed from a flag, it is parsed from an argument using `ParseFieldFromArg`.\n\nThe code also provides utility functions for parsing specific types of fields, such as `ParseUint`, `ParseInt`, `ParseFloat`, `ParseDenom`, `ParseCoin`, `ParseCoins`, `ParseSdkInt`, and `ParseSdkDec`. These functions are used by the main parsing functions to handle different field types.\n\nAdditionally, there are helper functions like `ParseNumFields`, `ParseExpectedQueryFnName`, and `ParseHasPagination` that provide information about the struct being parsed, such as the number of fields, the expected query function name, and whether the struct has pagination.\n\nHere's an example of how this code might be used in the larger project:\n\n```go\ntype MyStruct struct {\n    Name string\n    Age  int\n}\n\nflagAdvice := osmocli.FlagAdvice{}\nflags := pflag.NewFlagSet(\"my-command\", pflag.ContinueOnError)\nargs := []string{\"John\", \"25\"}\n\nparsedStruct, err := osmocli.ParseFieldsFromFlagsAndArgs[MyStruct](flagAdvice, flags, args)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"Parsed struct: %+v\\n\", parsedStruct)\n```\n\nThis would output:\n\n```\nParsed struct: {Name:John Age:25}\n```",
      "questions": "1. **Question:** What is the purpose of the `ParseFieldsFromFlagsAndArgs` function and how does it work with the provided arguments?\n\n   **Answer:** The `ParseFieldsFromFlagsAndArgs` function is used to parse arguments and flags from the command line input. It takes a `FlagAdvice`, a `pflag.FlagSet`, and a slice of strings as arguments. The function creates a new instance of the `reqP` type, iterates over its fields, and attempts to parse each field from either an argument or a flag using the provided `FlagAdvice` and `pflag.FlagSet`. It returns the parsed `reqP` instance and an error if there was an issue in parsing any field.\n\n2. **Question:** How does the `ParseField` function determine whether to parse a field from an argument or a flag?\n\n   **Answer:** The `ParseField` function first checks if there is a custom field parser provided in the `FlagAdvice`. If so, it uses the custom parser to parse the field. If not, it attempts to parse the field from a flag using the `ParseFieldFromFlag` function. If the field is not parsed from a flag, it then tries to parse the field from the provided argument using the `ParseFieldFromArg` function.\n\n3. **Question:** What is the purpose of the `ParseExpectedQueryFnName` function and how does it work?\n\n   **Answer:** The `ParseExpectedQueryFnName` function is used to extract the expected query function name from the `reqP` type. It creates a new instance of the `reqP` type, gets its string representation, and trims the prefix and suffix to extract the expected query function name. This can be useful for determining the appropriate query function to call based on the provided request type."
    },
    {
      "fileName": "query_cmd_wrap.go",
      "filePath": "osmoutils/osmocli/query_cmd_wrap.go",
      "url": "https://github.com/duality-labs/duality/osmoutils/osmocli/query_cmd_wrap.go",
      "summary": "The `osmocli` package contains code that provides a command-line interface (CLI) for querying data from a Cosmos SDK-based blockchain. The code is written in Go and uses the Cobra library to create CLI commands.\n\nThe `QueryDescriptor` struct defines the properties of a query command, such as its name, description, and the function to call on the blockchain to retrieve the data. The `BuildQueryCli` function takes a `QueryDescriptor` and a function that creates a gRPC client for the blockchain and returns a Cobra command that can be used to execute the query. The `SimpleQueryCmd` function is a convenience function that creates a simple query command for the common case where all proto fields appear as arguments in order.\n\nThe `AddQueryCmd` function adds a query command to an existing Cobra command. It takes a `QueryDescriptor`, a function that creates a gRPC client for the blockchain, and a function that returns the request message to send to the blockchain. The `callQueryClientFn` function calls the specified function on the gRPC client with the request message and returns the response message.\n\nThe `GetParams` function returns a Cobra command that retrieves the parameters for a module on the blockchain. It takes the name of the module and a function that creates a gRPC client for the blockchain.\n\nOverall, this code provides a flexible and extensible way to create query commands for a Cosmos SDK-based blockchain. It allows developers to define the properties of a query command and the function to call on the blockchain to retrieve the data, and provides a simple way to create and execute the command.",
      "questions": "1. What is the purpose of the `QueryDescriptor` struct?\n- The `QueryDescriptor` struct is used to store information about a query command, such as its name, description, flags, and how to parse its arguments.\n\n2. What is the purpose of the `BuildQueryCli` function?\n- The `BuildQueryCli` function is used to create a Cobra command for a query, based on a `QueryDescriptor` and a function that creates a gRPC client for the query.\n\n3. What is the purpose of the `callQueryClientFn` function?\n- The `callQueryClientFn` function is used to call a method on a gRPC client for a query, based on the name of the method and a request message, and return the response message or an error."
    },
    {
      "fileName": "string_formatter.go",
      "filePath": "osmoutils/osmocli/string_formatter.go",
      "url": "https://github.com/duality-labs/duality/osmoutils/osmocli/string_formatter.go",
      "summary": "The `osmocli` package contains code that is used to generate long descriptions for CLI commands in the duality project. The `LongMetadata` struct defines the metadata that is used to generate the long description. It contains the binary name, command prefix, short description, and an example header. The `NewLongMetadata` function creates a new instance of the `LongMetadata` struct and sets the command prefix based on the module name. \n\nThe `FormatLongDesc` function takes a long string and a `LongMetadata` struct as input and returns a formatted long description string. It uses the `text/template` package to parse the long string and replace any placeholders with the values from the `LongMetadata` struct. If the parsing fails, it panics with an error message. The formatted long description string is returned after trimming any leading or trailing white space.\n\nThe `FormatLongDescDirect` function is a convenience function that takes a long string and a module name as input and returns a formatted long description string. It calls the `FormatLongDesc` function with a new instance of the `LongMetadata` struct created using the module name.\n\nThis code is used to generate long descriptions for CLI commands in the duality project. Developers can use the `FormatLongDescDirect` function to generate a formatted long description string for a specific module and use it in the CLI command documentation. For example:\n\n```\nlongDesc := \"This command does something.\\n\\nUsage: {{.CommandPrefix}} command [args]\\n\\n{{.ExampleHeader}}\\n{{.CommandPrefix}} command arg1 arg2\"\nmoduleName := \"mymodule\"\nformattedLongDesc := FormatLongDescDirect(longDesc, moduleName)\n```\n\nThe `formattedLongDesc` variable will contain the following string:\n\n```\nThis command does something.\n\nUsage: $ duality q mymodule command [args]\n\nExample:\n$ duality q mymodule command arg1 arg2\n```",
      "questions": "1. What is the purpose of the `LongMetadata` struct?\n   \n   The `LongMetadata` struct is used to store information about a command's long description, including the binary name, command prefix, and an example header.\n\n2. What is the purpose of the `FormatLongDesc` function?\n   \n   The `FormatLongDesc` function takes a long description string and a `LongMetadata` struct, and returns a formatted string that includes the long description and example header.\n\n3. What is the difference between `NewLongMetadata` and `FormatLongDescDirect`?\n   \n   `NewLongMetadata` creates a new `LongMetadata` struct with a given module name, while `FormatLongDescDirect` takes a long description string and a module name, and returns a formatted string that includes the long description and example header."
    },
    {
      "fileName": "tx_cmd_wrap.go",
      "filePath": "osmoutils/osmocli/tx_cmd_wrap.go",
      "url": "https://github.com/duality-labs/duality/osmoutils/osmocli/tx_cmd_wrap.go",
      "summary": "The `osmocli` package contains code for building CLI commands for interacting with a Cosmos SDK-based blockchain. The `TxIndexCmd` function returns a Cobra command that is used to index transactions for a given module. The `TxCliDesc` struct defines the properties of a transaction command, including its use, short and long descriptions, number of arguments, and a function for parsing and building a message. The `AddTxCmd` function adds a transaction command to a given Cobra command, and the `BuildTxCli` function builds a Cobra command from a `TxCliDesc` struct. The `BuildCommandCustomFn` method builds a Cobra command from a `TxCliDesc` struct with custom flag overrides and field parsers.\n\nOverall, this code provides a framework for building CLI commands for interacting with a Cosmos SDK-based blockchain. It allows developers to easily define the properties of a transaction command and build a Cobra command from those properties. This code is likely used in the larger project to provide a user-friendly interface for interacting with the blockchain via the command line. Here is an example of how this code might be used to build a transaction command:\n\n```\ndesc := &TxCliDesc{\n    Use: \"mytx\",\n    Short: \"My custom transaction command\",\n    Long: \"This command does something cool\",\n    NumArgs: 2,\n    ParseAndBuildMsg: func(clientCtx client.Context, args []string, flags *pflag.FlagSet) (sdk.Msg, error) {\n        // Parse arguments and build a message\n    },\n    TxSignerFieldName: \"from\",\n    Flags: FlagDesc{\n        {\"flag1\", \"\", \"Flag 1\", true},\n        {\"flag2\", \"\", \"Flag 2\", true},\n    },\n}\ncmd := desc.BuildCommandCustomFn()\n```",
      "questions": "1. What is the purpose of the `TxIndexCmd` function?\n- The `TxIndexCmd` function returns a Cobra command that is used to index transactions for a given module.\n\n2. What is the purpose of the `TxCliDesc` struct?\n- The `TxCliDesc` struct is used to describe a CLI command for a transaction message. It includes information such as the command name, description, number of arguments, and a function to parse and build the message.\n\n3. What is the purpose of the `AddTxCmd` function?\n- The `AddTxCmd` function adds a new Cobra command to an existing command with the given transaction message and CLI description."
    }
  ],
  "folders": [],
  "summary": "The `osmocli` package provides a command-line interface (CLI) for interacting with the Osmocom cellular network stack and a Cosmos SDK-based blockchain. It offers a flexible and extensible way to handle command-line flags, create query and transaction commands, and generate formatted long descriptions for CLI commands.\n\nThe `flag_advice.go` file defines types and functions for parsing and handling command-line flags. It allows users to customize the behavior of the CLI by defining custom flag names and parsers. For example:\n\n```go\nflagAdvice := osmocli.FlagAdvice{\n    HasPagination: true,\n    CustomFlagOverrides: map[string]string{\n        \"flag1\": \"custom_flag1\",\n    },\n    CustomFieldParsers: map[string]osmocli.CustomFieldParserFn{\n        \"field1\": osmocli.FlagOnlyParser(func() interface{} { return new(int) }),\n    },\n}\n```\n\nThe `index_cmd.go` file defines a CLI command that can be used to query information about a specific module in an Osmocom cellular network. Here's an example of how to create a root command and add a module command:\n\n```go\nrootCmd := &cobra.Command{Use: \"duality\"}\nmoduleCmd := osmocli.IndexCmd(\"module_name\")\nrootCmd.AddCommand(moduleCmd)\n```\n\nThe `parsers.go` file provides functionality for parsing command-line arguments and flags for the duality project. It uses reflection to dynamically parse the fields of a given struct based on the provided arguments and flags:\n\n```go\ntype MyStruct struct {\n    Name string\n    Age  int\n}\n\nflagAdvice := osmocli.FlagAdvice{}\nflags := pflag.NewFlagSet(\"my-command\", pflag.ContinueOnError)\nargs := []string{\"John\", \"25\"}\n\nparsedStruct, err := osmocli.ParseFieldsFromFlagsAndArgs[MyStruct](flagAdvice, flags, args)\n```\n\nThe `query_cmd_wrap.go` file provides a way to create query commands for a Cosmos SDK-based blockchain. It allows developers to define the properties of a query command and the function to call on the blockchain to retrieve the data:\n\n```go\nqueryDesc := osmocli.QueryDescriptor{\n    Name: \"myquery\",\n    Desc: \"My custom query command\",\n    QueryFn: func(clientCtx client.Context, req *myquery.Request) (*myquery.Response, error) {\n        // Call the blockchain to retrieve the data\n    },\n}\nqueryCmd := osmocli.BuildQueryCli(queryDesc, createGrpcClient)\n```\n\nThe `string_formatter.go` file generates long descriptions for CLI commands. Developers can use the `FormatLongDescDirect` function to generate a formatted long description string for a specific module:\n\n```go\nlongDesc := \"This command does something.\\n\\nUsage: {{.CommandPrefix}} command [args]\\n\\n{{.ExampleHeader}}\\n{{.CommandPrefix}} command arg1 arg2\"\nmoduleName := \"mymodule\"\nformattedLongDesc := osmocli.FormatLongDescDirect(longDesc, moduleName)\n```\n\nThe `tx_cmd_wrap.go` file provides a framework for building CLI commands for interacting with a Cosmos SDK-based blockchain. It allows developers to easily define the properties of a transaction command and build a Cobra command from those properties:\n\n```go\ndesc := &osmocli.TxCliDesc{\n    Use: \"mytx\",\n    Short: \"My custom transaction command\",\n    Long: \"This command does something cool\",\n    NumArgs: 2,\n    ParseAndBuildMsg: func(clientCtx client.Context, args []string, flags *pflag.FlagSet) (sdk.Msg, error) {\n        // Parse arguments and build a message\n    },\n    TxSignerFieldName: \"from\",\n    Flags: osmocli.FlagDesc{\n        {\"flag1\", \"\", \"Flag 1\", true},\n        {\"flag2\", \"\", \"Flag 2\", true},\n    },\n}\ncmd := desc.BuildCommandCustomFn()\n```",
  "questions": ""
}