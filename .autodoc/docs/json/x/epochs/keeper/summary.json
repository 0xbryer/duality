{
  "folderName": "keeper",
  "folderPath": ".autodoc/docs/json/x/epochs/keeper",
  "url": "https://github.com/duality-labs/duality/utodoc/docs/json/x/epochs/keeper",
  "files": [
    {
      "fileName": "abci.go",
      "filePath": "x/epochs/keeper/abci.go",
      "url": "https://github.com/duality-labs/duality/epochs/keeper/abci.go",
      "summary": "The `BeginBlocker` function in the `keeper` package of the `duality` project is responsible for managing epochs. An epoch is a period of time during which certain actions can be taken in the system. The purpose of this function is to determine when a new epoch should begin and to perform the necessary actions to start it.\n\nThe function starts by iterating over all the epoch information stored in the system. For each epoch, it checks whether the current block time is after the epoch start time. If it is not, the function returns and does nothing. If it is, the function checks whether epoch counting has started. If it has not, the function signals that it needs to start. The function then calculates the end time of the current epoch and checks whether the current block time is after that end time or if epoch counting needs to start. If neither of these conditions is true, the function returns and does nothing.\n\nIf a new epoch needs to start, the function sets the current epoch start height to the current block height. If epoch counting needs to start, the function sets the epoch counting started flag to true, sets the current epoch to 1, and sets the current epoch start time to the epoch start time. If epoch counting has already started, the function emits an event indicating the end of the previous epoch, performs any necessary actions after the epoch ends, increments the current epoch, sets the current epoch start time to the end time of the previous epoch, and emits an event indicating the start of the new epoch. Finally, the function sets the epoch information in the system and performs any necessary actions before the epoch starts.\n\nThis function is a critical part of the `duality` project as it manages the timing of epochs, which is essential for the proper functioning of the system. Other parts of the system can use the epoch information stored in the system to determine when certain actions can be taken. For example, a smart contract might use the epoch information to determine when it can be executed. The `BeginBlocker` function can be called by other parts of the system to start a new epoch manually if necessary.",
      "questions": "1. What is the purpose of the `BeginBlocker` function in the epochs module?\n- The `BeginBlocker` function is a method of the `Keeper` struct in the epochs module that is called at the beginning of each block. It iterates through all epoch info and starts a new epoch if necessary.\n\n2. What is the significance of the `shouldInitialEpochStart` variable?\n- The `shouldInitialEpochStart` variable is a boolean that is set to true if epoch counting has not yet started. It is used to determine whether a new epoch should be started or not.\n\n3. What events are emitted when a new epoch starts or ends?\n- When a new epoch starts, the `BeginBlocker` function emits an event of type `EventTypeEpochStart` with attributes `AttributeEpochNumber` and `AttributeEpochStartTime`. When an epoch ends, the function emits an event of type `EventTypeEpochEnd` with attribute `AttributeEpochNumber`."
    },
    {
      "fileName": "epoch.go",
      "filePath": "x/epochs/keeper/epoch.go",
      "url": "https://github.com/duality-labs/duality/epochs/keeper/epoch.go",
      "summary": "The `keeper` package contains the implementation of the `Keeper` struct, which is responsible for managing the state of the `EpochInfo` objects in the `duality` project. The `EpochInfo` object contains information about an epoch, such as its start time and identifier. The `Keeper` struct provides methods for adding, retrieving, and deleting `EpochInfo` objects, as well as iterating through all the epochs.\n\nThe `GetEpochInfo` method retrieves an `EpochInfo` object by its identifier. It takes a `sdk.Context` object and a string identifier as input and returns an `EpochInfo` object. If the identifier is not found, it returns an empty `EpochInfo` object.\n\nThe `AddEpochInfo` method adds a new `EpochInfo` object to the state. It takes a `sdk.Context` object and an `EpochInfo` object as input and returns an error if the epoch fails validation or if the identifier already exists. If the start time is not set, it sets it to the current block time. It also sets the epoch start height.\n\nThe `setEpochInfo` method sets an `EpochInfo` object in the state. It takes a `sdk.Context` object and an `EpochInfo` object as input and does not return anything.\n\nThe `DeleteEpochInfo` method deletes an `EpochInfo` object from the state. It takes a `sdk.Context` object and a string identifier as input and does not return anything.\n\nThe `IterateEpochInfo` method iterates through all the `EpochInfo` objects in the state. It takes a `sdk.Context` object and a function as input. The function takes an index and an `EpochInfo` object as input and returns a boolean value. If the boolean value is true, the iteration stops. Otherwise, it continues.\n\nThe `AllEpochInfos` method returns all the `EpochInfo` objects in the state. It takes a `sdk.Context` object as input and returns a slice of `EpochInfo` objects.\n\nThe `NumBlocksSinceEpochStart` method returns the number of blocks since the epoch started. It takes a `sdk.Context` object and a string identifier as input and returns an integer value. If the identifier is not found, it returns an error.\n\nOverall, the `keeper` package provides a way to manage the state of the `EpochInfo` objects in the `duality` project. It allows for adding, retrieving, and deleting `EpochInfo` objects, as well as iterating through all the epochs and getting the number of blocks since the epoch started. This package is likely used in conjunction with other packages in the project to manage the overall state of the system.",
      "questions": "1. What is the purpose of the `duality-labs/duality/x/epochs/types` package?\n- The `duality-labs/duality/x/epochs/types` package is used to define the data types related to epochs.\n\n2. What is the purpose of the `AddEpochInfo` function?\n- The `AddEpochInfo` function is used to add a new epoch info to the store. It also sets the start time if left unset, and sets the epoch start height.\n\n3. What is the purpose of the `IterateEpochInfo` function?\n- The `IterateEpochInfo` function is used to iterate through the epochs in the store and execute a function on each epoch."
    },
    {
      "fileName": "genesis.go",
      "filePath": "x/epochs/keeper/genesis.go",
      "url": "https://github.com/duality-labs/duality/epochs/keeper/genesis.go",
      "summary": "The code provided is a part of the duality project and is located in the `keeper` package. The purpose of this code is to manage epoch information in the duality blockchain. \n\nThe `InitGenesis` function is called during the initialization of the blockchain and sets the epoch information from the genesis state. It takes in two arguments, `ctx` of type `sdk.Context` and `genState` of type `types.GenesisState`. The function iterates over all the epochs in the `genState` and calls the `AddEpochInfo` function of the `Keeper` struct for each epoch. If an error occurs during the addition of epoch information, the function panics.\n\nThe `ExportGenesis` function is called during the export of the blockchain's genesis state. It takes in one argument, `ctx` of type `sdk.Context`. The function creates a new `GenesisState` struct using the `DefaultGenesis` function of the `types` package. It then sets the `Epochs` field of the `GenesisState` struct to the result of the `AllEpochInfos` function of the `Keeper` struct. The `AllEpochInfos` function returns all the epoch information stored in the blockchain. The `ExportGenesis` function then returns the `GenesisState` struct.\n\nThis code is important for managing epoch information in the duality blockchain. Epochs are periods of time in the blockchain during which certain rules or conditions apply. This code allows for the addition and retrieval of epoch information, which can be used by other parts of the duality project to enforce rules or conditions during specific epochs. \n\nFor example, if the duality project wanted to implement a reward system during a specific epoch, it could use the epoch information managed by this code to determine when that epoch starts and ends. It could then use that information to enforce the reward system during that epoch. \n\nOverall, this code is a crucial part of the duality project's epoch management system and allows for the implementation of various rules and conditions during specific epochs.",
      "questions": "1. What is the purpose of the `AddEpochInfo` function called in `InitGenesis`?\n- The `AddEpochInfo` function is used to set epoch information in the keeper.\n\n2. What is the `ExportGenesis` function used for?\n- The `ExportGenesis` function is used to return the exported genesis of the capability module.\n\n3. What is the `types.GenesisState` struct and where is it defined?\n- The `types.GenesisState` struct is defined in the `epochs/types` package and is used to store the genesis state of the epochs module."
    },
    {
      "fileName": "grpc_query.go",
      "filePath": "x/epochs/keeper/grpc_query.go",
      "url": "https://github.com/duality-labs/duality/epochs/keeper/grpc_query.go",
      "summary": "The code in this file is a part of the duality project and is located in the `keeper` package. The purpose of this code is to define a gRPC query server for the `x/epochs` module of the duality project. The `Querier` struct is defined as a wrapper around the `Keeper` struct of the `x/epochs` module, which provides gRPC method handlers. The `Keeper` struct is responsible for managing the state of the `x/epochs` module.\n\nThe `NewQuerier` function initializes a new `Querier` struct with the provided `Keeper` struct. The `EpochInfos` method provides running epoch information by calling the `AllEpochInfos` method of the `Keeper` struct. The `CurrentEpoch` method provides the current epoch of a specified identifier by calling the `GetEpochInfo` method of the `Keeper` struct.\n\nThis code is used to provide a gRPC interface for querying epoch information in the duality project. The `EpochInfos` method can be used to retrieve information about all running epochs, while the `CurrentEpoch` method can be used to retrieve information about a specific epoch. This code is an important part of the duality project as it allows external clients to query epoch information in a standardized way. \n\nExample usage of the `EpochInfos` method:\n```\nconn, err := grpc.Dial(address, grpc.WithInsecure())\nif err != nil {\n    log.Fatalf(\"Failed to dial: %v\", err)\n}\ndefer conn.Close()\n\nclient := types.NewQueryClient(conn)\n\nresp, err := client.EpochInfos(context.Background(), &types.QueryEpochsInfoRequest{})\nif err != nil {\n    log.Fatalf(\"Failed to query epoch infos: %v\", err)\n}\n\nfor _, epoch := range resp.Epochs {\n    fmt.Printf(\"Epoch %s started at %s\\n\", epoch.Identifier, epoch.StartTime)\n}\n```\n\nExample usage of the `CurrentEpoch` method:\n```\nconn, err := grpc.Dial(address, grpc.WithInsecure())\nif err != nil {\n    log.Fatalf(\"Failed to dial: %v\", err)\n}\ndefer conn.Close()\n\nclient := types.NewQueryClient(conn)\n\nresp, err := client.CurrentEpoch(context.Background(), &types.QueryCurrentEpochRequest{Identifier: \"epoch-1\"})\nif err != nil {\n    log.Fatalf(\"Failed to query current epoch: %v\", err)\n}\n\nfmt.Printf(\"Current epoch of epoch-1 is %d\\n\", resp.CurrentEpoch)\n```",
      "questions": "1. What is the purpose of this code file?\n- This code file is a part of the `duality` project and defines a gRPC method handler for querying epoch information.\n\n2. What dependencies does this code file have?\n- This code file imports several packages, including `cosmos-sdk/types`, `google.golang.org/grpc/codes`, and `google.golang.org/grpc/status`.\n\n3. What functionality does this code file provide?\n- This code file provides two gRPC method handlers: `EpochInfos` which returns running epochInfos, and `CurrentEpoch` which returns the current epoch of a specified identifier."
    },
    {
      "fileName": "hooks.go",
      "filePath": "x/epochs/keeper/hooks.go",
      "url": "https://github.com/duality-labs/duality/epochs/keeper/hooks.go",
      "summary": "The code provided is a part of the `keeper` package in the `duality` project. The purpose of this code is to define two functions, `AfterEpochEnd` and `BeforeEpochStart`, which are called at the end and start of an epoch, respectively. \n\nAn epoch is a period of time in a blockchain network during which a set of blocks are produced. The duration of an epoch is determined by the network's consensus algorithm. At the end of an epoch, the network may perform certain actions, such as updating validators or redistributing rewards. \n\nThe `AfterEpochEnd` function is called at the end of an epoch and takes three arguments: `ctx`, `identifier`, and `epochNumber`. `ctx` is a context object that provides access to the blockchain state. `identifier` is a string that identifies the epoch, and `epochNumber` is the number of the epoch. This function calls a hook function `AfterEpochEnd` if it is defined in the `hooks` object. The `hooks` object is a part of the `Keeper` struct and is used to register hook functions that are called at various points during the blockchain's lifecycle. \n\nThe `BeforeEpochStart` function is called at the start of an epoch and takes the same arguments as `AfterEpochEnd`. This function calls a hook function `BeforeEpochStart` if it is defined in the `hooks` object. \n\nThese functions are designed to be used as hooks in the `duality` project. Developers can define their own hook functions and register them with the `hooks` object to perform custom actions at the start or end of an epoch. For example, a developer may define a hook function that updates a database with information about the current epoch's validators. \n\nHere is an example of how a hook function can be defined and registered with the `hooks` object:\n\n```\nfunc myHookFunction(ctx sdk.Context, identifier string, epochNumber int64) error {\n    // perform custom actions here\n    return nil\n}\n\n// register the hook function\nk.hooks.AfterEpochEnd = myHookFunction\n```",
      "questions": "1. What is the purpose of the `Keeper` type and where is it defined?\n- The `Keeper` type is used in the `AfterEpochEnd` and `BeforeEpochStart` functions, but its definition is not shown in this code snippet. A smart developer might want to know where this type is defined and what its role is in the project.\n\n2. What is the `hooks` field and how is it initialized?\n- The `hooks` field is used in both the `AfterEpochEnd` and `BeforeEpochStart` functions, but it is not clear from this code snippet what it represents or how it is initialized. A smart developer might want to know more about this field and how it fits into the overall architecture of the project.\n\n3. What is the purpose of the `osmoutils.ApplyFuncIfNoError()` function?\n- Both the `AfterEpochEnd` and `BeforeEpochStart` functions use the `osmoutils.ApplyFuncIfNoError()` function to handle errors, but it is not clear from this code snippet what this function does or how it works. A smart developer might want to know more about this function and how it is used in the project."
    },
    {
      "fileName": "keeper.go",
      "filePath": "x/epochs/keeper/keeper.go",
      "url": "https://github.com/duality-labs/duality/epochs/keeper/keeper.go",
      "summary": "The `keeper` package contains the implementation of the `Keeper` struct, which is responsible for managing the state of the `epochs` module in the larger `duality` project. The `Keeper` struct has two fields: `storeKey` of type `sdk.StoreKey` and `hooks` of type `types.EpochHooks`. \n\nThe `NewKeeper` function is a constructor for the `Keeper` struct. It takes a `storeKey` of type `sdk.StoreKey` as input and returns a new instance of the `Keeper` struct. This function is used to initialize a new `Keeper` instance when the `epochs` module is initialized.\n\nThe `SetHooks` method is used to set the `hooks` field of the `Keeper` struct. It takes an `EpochHooks` object as input and returns a pointer to the `Keeper` instance. If the `hooks` field has already been set, this method will panic. This method is used to set the hooks for the `epochs` module, which are called at the beginning and end of each epoch.\n\nThe `Logger` method is used to get a logger instance for the `epochs` module. It takes a `sdk.Context` object as input and returns a `log.Logger` instance. This method is used to log messages related to the `epochs` module.\n\nOverall, the `keeper` package provides the implementation of the `Keeper` struct, which is responsible for managing the state of the `epochs` module in the larger `duality` project. The `NewKeeper` function is used to initialize a new `Keeper` instance, the `SetHooks` method is used to set the hooks for the `epochs` module, and the `Logger` method is used to get a logger instance for the `epochs` module.",
      "questions": "1. What is the purpose of the `Keeper` struct?\n   - The `Keeper` struct is used to store a `sdk.StoreKey` and `types.EpochHooks` and provide methods to interact with them.\n\n2. What is the `NewKeeper` function used for?\n   - The `NewKeeper` function returns a new instance of the `Keeper` struct with the provided `sdk.StoreKey`.\n\n3. What is the purpose of the `SetHooks` function?\n   - The `SetHooks` function is used to set the `types.EpochHooks` for the `Keeper` instance, but it can only be called once."
    }
  ],
  "folders": [],
  "summary": "The `keeper` package in the `duality` project is responsible for managing the state of the `epochs` module, which deals with epochs - periods of time during which certain actions can be taken in the system. The package contains several files that define functions and structs for managing epoch information, such as adding, retrieving, and deleting `EpochInfo` objects, as well as iterating through all the epochs.\n\nThe `abci.go` file contains the `BeginBlocker` function, which is responsible for managing the start and end of epochs. It checks whether a new epoch should begin and performs the necessary actions to start it. This function is critical for the proper functioning of the system, as it manages the timing of epochs.\n\nThe `epoch.go` file defines the `Keeper` struct and its methods for managing the state of `EpochInfo` objects. It provides methods for adding, retrieving, and deleting `EpochInfo` objects, as well as iterating through all the epochs and getting the number of blocks since the epoch started.\n\nThe `genesis.go` file contains functions for initializing and exporting the blockchain's genesis state, which includes epoch information. The `InitGenesis` function sets the epoch information from the genesis state, while the `ExportGenesis` function exports the current epoch information to the genesis state.\n\nThe `grpc_query.go` file defines a gRPC query server for the `x/epochs` module, allowing external clients to query epoch information in a standardized way. The `Querier` struct wraps around the `Keeper` struct and provides gRPC method handlers for retrieving running epoch information and the current epoch of a specified identifier.\n\nThe `hooks.go` file defines two functions, `AfterEpochEnd` and `BeforeEpochStart`, which are called at the end and start of an epoch, respectively. Developers can define their own hook functions and register them with the `hooks` object to perform custom actions at the start or end of an epoch.\n\nThe `keeper.go` file provides the implementation of the `Keeper` struct, which is responsible for managing the state of the `epochs` module. It contains methods for initializing a new `Keeper` instance, setting hooks for the `epochs` module, and getting a logger instance for the `epochs` module.\n\nHere's an example of how to use the `Keeper` struct to add a new `EpochInfo` object:\n\n```go\nk := keeper.NewKeeper(storeKey)\nepochInfo := types.EpochInfo{\n    Identifier: \"epoch-1\",\n    StartTime:  time.Now(),\n}\nerr := k.AddEpochInfo(ctx, epochInfo)\nif err != nil {\n    log.Fatalf(\"Failed to add epoch info: %v\", err)\n}\n```\n\nOverall, the `keeper` package plays a crucial role in the `duality` project by managing the state of the `epochs` module, which is essential for the proper functioning of the system. Other parts of the system can use the epoch information stored in the system to determine when certain actions can be taken, such as executing a smart contract.",
  "questions": ""
}