{
  "folderName": "keeper",
  "folderPath": ".autodoc/docs/json/x/incentives/keeper",
  "url": "https://github.com/duality-labs/duality/utodoc/docs/json/x/incentives/keeper",
  "files": [
    {
      "fileName": "gauge.go",
      "filePath": "x/incentives/keeper/gauge.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/gauge.go",
      "summary": "The `keeper` package contains the implementation of the `Keeper` struct, which is responsible for managing the state of the `duality` project. This file contains functions that allow for the creation, retrieval, and modification of gauges, which are used to distribute rewards to users based on certain conditions.\n\nThe `GetLastGaugeID` function retrieves the ID of the last used gauge from the key-value store. The `SetLastGaugeID` function sets the ID of the last used gauge to the provided ID.\n\nThe `getGaugesFromIterator` function iterates over everything in a gauge's iterator until it reaches the end and returns all gauges iterated over. The `setGaugeRefs` function sets the gauge references based on the gauge's status (upcoming, active, or finished).\n\nThe `setGauge` function sets the gauge inside the store. The `CreateGauge` function creates a gauge and sends coins to the gauge. The `AddToGaugeRewards` function adds coins to a gauge. The `GetGaugeByID` function retrieves a gauge from the gauge ID. The `GetGauges` function returns upcoming, active, and finished gauges. The `GetNotFinishedGauges` function returns both upcoming and active gauges. The `GetEpochInfo` function returns the EpochInfo struct given the context.\n\nThe `moveUpcomingGaugeToActiveGauge` function moves a gauge that has reached its start time from an upcoming to an active status. The `moveActiveGaugeToFinishedGauge` function moves a gauge that has completed its distribution from an active to a finished status. The `GetActiveGauges` function returns active gauges. The `GetUpcomingGauges` function returns upcoming gauges. The `GetFinishedGauges` function returns finished gauges. The `GetGaugesByPair` function returns gauges by pair.\n\nOverall, this file provides the functionality to create, modify, and retrieve gauges, which are used to distribute rewards to users based on certain conditions. These functions are used in the larger `duality` project to manage the distribution of rewards to users.",
      "questions": "1. What is the purpose of the `duality` project and how does this code file fit into the project?\n- This code file is a part of the `keeper` package in the `duality` project. It contains functions related to managing gauges and rewards in the project.\n\n2. What is the role of the `GetLastGaugeID` and `SetLastGaugeID` functions?\n- `GetLastGaugeID` returns the last used gauge ID from the key-value store in the context. `SetLastGaugeID` sets the last used gauge ID to the provided ID in the key-value store in the context.\n\n3. What is the purpose of the `moveUpcomingGaugeToActiveGauge` and `moveActiveGaugeToFinishedGauge` functions?\n- `moveUpcomingGaugeToActiveGauge` moves a gauge that has reached its start time from an upcoming to an active status. `moveActiveGaugeToFinishedGauge` moves a gauge that has completed its distribution from an active to a finished status."
    },
    {
      "fileName": "genesis.go",
      "filePath": "x/incentives/keeper/genesis.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/genesis.go",
      "summary": "The code provided is a part of the duality project and is located in the `keeper` package. The purpose of this code is to initialize and export the state of the incentives module. The incentives module is responsible for managing the incentives and rewards for users who participate in the network. \n\nThe `InitGenesis` function initializes the state of the incentives module from a provided genesis state. It takes in a context and a genesis state as input parameters. The function sets the module's parameters, initializes all the stakes and gauges, and sets the last stake and gauge IDs. If there is an error in initializing the stakes or gauges, the function returns without setting the state.\n\nThe `ExportGenesis` function exports the state of the incentives module. It takes in a context as an input parameter and returns a pointer to a `GenesisState` struct. The function gets the module's parameters, all the not finished gauges, the last gauge and stake IDs, and all the stakes. The exported state can be used to restore the state of the incentives module at a later time.\n\nThe `InitializeAllStakes` function initializes all the stakes and stores them correctly. It takes in a context and a set of stakes as input parameters. The function iterates over all the stakes and sets each stake and its references. If there is an error in setting the stake or its references, the function returns with an error.\n\nThe `InitializeAllGauges` function initializes all the gauges and stores them correctly. It takes in a context and a set of gauges as input parameters. The function iterates over all the gauges and sets each gauge and its references. If there is an error in setting the gauge or its references, the function returns with an error.\n\nOverall, this code is an essential part of the incentives module in the duality project. It initializes and exports the state of the module, which is crucial for managing the incentives and rewards for users who participate in the network. The `InitializeAllStakes` and `InitializeAllGauges` functions are used to set the state of the stakes and gauges, respectively. The exported state can be used to restore the state of the incentives module at a later time.",
      "questions": "1. What is the purpose of the `duality-labs/duality/x/incentives/types` package?\n- The `duality-labs/duality/x/incentives/types` package defines the types used in the incentives module.\n\n2. What is the difference between `InitGenesis` and `ExportGenesis` functions?\n- `InitGenesis` initializes the incentives module's state from a provided genesis state, while `ExportGenesis` returns the x/incentives module's exported genesis.\n\n3. What is the purpose of the `InitializeAllStakes` and `InitializeAllGauges` functions?\n- `InitializeAllStakes` and `InitializeAllGauges` take a set of stakes/gauges and initialize state to be storing them all correctly."
    },
    {
      "fileName": "hooks.go",
      "filePath": "x/incentives/keeper/hooks.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/hooks.go",
      "summary": "This code is a part of the duality project and is located in the `keeper` package. The purpose of this code is to define hooks that are called before and after each epoch in the duality blockchain. These hooks are used to perform certain actions at the start and end of each epoch. \n\nThe `BeforeEpochStart` hook is called at the start of each epoch and takes in the epoch identifier and epoch number as arguments. In this code, the `BeforeEpochStart` function simply returns nil, indicating that no action needs to be taken at the start of the epoch.\n\nThe `AfterEpochEnd` hook is called at the end of each epoch and takes in the epoch identifier and epoch number as arguments. In this code, the `AfterEpochEnd` function performs several actions related to distributing rewards to users. First, it checks if the current epoch is the distribution epoch specified in the parameters. If it is, it retrieves the upcoming gauges and checks if any of them are active. If an upcoming gauge is active, it is moved to the active gauges list. Next, it retrieves the active gauges and filters out any perpetual gauges. The remaining gauges are then used to distribute rewards to users. \n\nThe `Hooks` struct is a wrapper for the `Keeper` struct and implements the `EpochHooks` interface. The `Hooks` struct has two methods, `BeforeEpochStart` and `AfterEpochEnd`, which simply call the corresponding methods in the `Keeper` struct. \n\nOverall, this code is used to define hooks that are called at the start and end of each epoch in the duality blockchain. These hooks are used to perform actions related to distributing rewards to users. The `BeforeEpochStart` hook does not perform any actions, while the `AfterEpochEnd` hook retrieves and distributes rewards to users based on the active gauges. \n\nExample usage:\n```\n// create a new keeper\nk := NewKeeper()\n\n// get the hooks for the keeper\nhooks := k.Hooks()\n\n// register the hooks with the epoch module\nepochModule.RegisterEpochHooks(hooks)\n```",
      "questions": "1. What is the purpose of this code?\n   \n   This code defines the `BeforeEpochStart` and `AfterEpochEnd` hooks for the `incentives` module of the `duality` project. The `AfterEpochEnd` hook distributes rewards to active gauges at the end of an epoch.\n\n2. What other modules or packages does this code import?\n   \n   This code imports `github.com/duality-labs/duality/x/epochs/types`, `github.com/duality-labs/duality/x/incentives/types`, and `github.com/cosmos/cosmos-sdk/types`.\n\n3. What is the relationship between the `BeforeEpochStart` and `AfterEpochEnd` functions defined in this code and the `EpochHooks` interface defined in `github.com/duality-labs/duality/x/epochs/types`?\n   \n   The `BeforeEpochStart` and `AfterEpochEnd` functions defined in this code implement the `BeforeEpochStart` and `AfterEpochEnd` functions of the `EpochHooks` interface defined in `github.com/duality-labs/duality/x/epochs/types`. The `Hooks` struct defined in this code is used to wrap the `Keeper` and provide the implementation of the `EpochHooks` interface."
    },
    {
      "fileName": "invariants.go",
      "filePath": "x/incentives/keeper/invariants.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/invariants.go",
      "summary": "The `keeper` package contains two functions that register and execute invariants for the `duality` project's governance module. \n\nThe `RegisterInvariants` function registers two invariants: `AccumulationStoreInvariant` and `StakesBalancesInvariant`. These invariants are used to ensure that the sum of all stakes at a given duration is equal to the value stored within the accumulation store and that the module balance and the sum of all tokens within all stakes have the equivalent amount of tokens, respectively. \n\nThe `AccumulationStoreInvariant` function checks the sum of all stakes at different durations against the value stored within the accumulation store. It does this by first getting the module account and all balances associated with it. It then loops through all denoms on the stakeup module and checks the sum of all stakes at different durations against the value stored within the accumulation store. If the sum of all stakes at a given duration is not equal to the value stored within the accumulation store, an error message is returned. \n\nThe `StakesBalancesInvariant` function checks that the module balance and the sum of all tokens within all stakes have the equivalent amount of tokens. It does this by first getting the module account and all balances associated with it. It then loops through all denoms on the stakeup module and checks that the sum of all tokens within all stakes is equal to the module balance. If the sum of all tokens within all stakes is not equal to the module balance, an error message is returned.\n\nThese functions are important for ensuring the integrity of the `duality` project's governance module. They can be used to detect and prevent errors in the system, which could lead to incorrect calculations or other issues. \n\nExample usage of these functions would involve calling `RegisterInvariants` during the initialization of the governance module and then periodically executing the registered invariants to ensure that the system is functioning correctly.",
      "questions": "1. What is the purpose of the `RegisterInvariants` function?\n   - The `RegisterInvariants` function registers governance invariants for the `duality` project.\n2. What does the `AccumulationStoreInvariant` function do?\n   - The `AccumulationStoreInvariant` function ensures that the sum of all stakes at a given duration is equal to the value stored within the accumulation store.\n3. What is the purpose of the `StakesBalancesInvariant` function?\n   - The `StakesBalancesInvariant` function ensures that the module balance and the sum of all tokens within all stakes have the equivalent amount of tokens."
    },
    {
      "fileName": "iterator.go",
      "filePath": "x/incentives/keeper/iterator.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/iterator.go",
      "summary": "This file contains the implementation of the Keeper struct for the duality project's incentives module. The Keeper struct is responsible for managing the state of the incentives module, which includes storing and retrieving data from the key-value store.\n\nThe `iterator` function returns an iterator over all gauges in the {prefix} space of state. It takes in a context and a prefix as arguments and returns an iterator. This function is used to iterate over all the gauges in the state and perform operations on them.\n\nThe `iteratorStartEnd` function is similar to the `iterator` function, but it takes in two additional arguments, `start` and `end`, which define the range of keys to iterate over. This function is used to iterate over a specific range of keys in the state.\n\nThe `UnmarshalRefArray` function takes in a byte slice and unmarshals it into an array of uint64 values. This function is used to deserialize data stored in the key-value store.\n\nThe `getStakesFromIterator` function takes in a context and an iterator and returns an array of single stake units by period defined by the x/stakeup module. This function is used to retrieve stakes from the key-value store and return them as an array.\n\nThe `getIDsFromIterator` function takes in an iterator and returns an array of uint64 values. This function is used to retrieve stake IDs from the key-value store and return them as an array.\n\nOverall, this file provides the necessary functions to manage the state of the incentives module in the duality project. These functions are used to retrieve and manipulate data stored in the key-value store.",
      "questions": "1. What is the purpose of the `UnmarshalRefArray` function?\n- The `UnmarshalRefArray` function is used to unmarshal a byte slice into an array of unsigned 64-bit integers.\n\n2. What is the difference between the `iterator` and `iteratorStartEnd` functions?\n- The `iterator` function returns an iterator over all gauges in the specified prefix space of state, while the `iteratorStartEnd` function returns an iterator over all gauges in the specified start and end range of state.\n\n3. What is the purpose of the `getStakesFromIterator` function?\n- The `getStakesFromIterator` function returns an array of single stake units by period defined by the x/stakeup module, by iterating over a provided iterator and retrieving the stakes associated with each stake ID."
    },
    {
      "fileName": "keeper.go",
      "filePath": "x/incentives/keeper/keeper.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/keeper.go",
      "summary": "The `Keeper` struct in the `keeper` package provides a way to manage the storage of the incentives module in the duality project. The `Keeper` struct has several fields, including `storeKey`, `paramSpace`, `hooks`, `ak`, `bk`, `ek`, `dk`, and `distributor`. \n\nThe `storeKey` field is of type `sdk.StoreKey` and is used to access the module's data in the application's main store. The `paramSpace` field is of type `paramtypes.Subspace` and is used to manage the module's parameters. The `hooks` field is of type `types.IncentiveHooks` and is used to manage the module's hooks. The `ak` field is of type `types.AccountKeeper` and is used to manage accounts in the application. The `bk` field is of type `types.BankKeeper` and is used to manage the application's bank. The `ek` field is of type `types.EpochKeeper` and is used to manage epochs in the application. The `dk` field is of type `types.DexKeeper` and is used to manage the application's decentralized exchange. Finally, the `distributor` field is of type `Distributor` and is used to manage the distribution of incentives.\n\nThe `NewKeeper` function returns a new instance of the `Keeper` struct. It takes in several parameters, including `storeKey`, `paramSpace`, `ak`, `bk`, `ek`, and `dk`. If the `paramSpace` parameter does not have a key table, it is set to the key table of the `types` package. The function then creates a new `Keeper` struct with the given parameters and sets the `distributor` field to a new instance of the `Distributor` struct.\n\nThe `SetHooks` function sets the incentives hooks for the `Keeper` struct. It takes in an `ih` parameter of type `types.IncentiveHooks`. If the `hooks` field is not `nil`, the function panics. Otherwise, the `hooks` field is set to the given `ih` parameter.\n\nThe `Logger` function returns a logger instance for the incentives module. It takes in a `ctx` parameter of type `sdk.Context` and returns a logger instance with the module name set to `\"x/incentives\"`.\n\nThe `GetModuleBalance` function returns the full balance of the module. It takes in a `ctx` parameter of type `sdk.Context` and returns the balance of the module's account.\n\nThe `GetModuleStakedCoins` function returns the staked balance of the module. It takes in a `ctx` parameter of type `sdk.Context` and returns the staked balance of the module's account.",
      "questions": "1. What is the purpose of the `Keeper` struct and what are its dependencies?\n- The `Keeper` struct provides a way to manage incentives module storage and depends on several other types including `AccountKeeper`, `BankKeeper`, `EpochKeeper`, `DexKeeper`, and `Distributor`.\n2. What is the purpose of the `NewKeeper` function and what does it return?\n- The `NewKeeper` function returns a new instance of the `Keeper` struct and takes several arguments including a `StoreKey`, `Subspace`, and several other dependencies.\n3. What is the purpose of the `GetModuleStakedCoins` function and how does it work?\n- The `GetModuleStakedCoins` function returns the staked balance of the module by getting all not unstaking and not finished unstaking stakes using the `GetStakes` function."
    },
    {
      "fileName": "lock_refs.go",
      "filePath": "x/incentives/keeper/lock_refs.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/lock_refs.go",
      "summary": "The `keeper` package contains functions that handle the storage and retrieval of data related to incentives and staking in the Duality project. The `addStakeRefs` and `deleteStakeRefs` functions are used to add and delete reference keys for a given stake. These reference keys are used to track the staked assets and calculate the incentives that should be rewarded to the staker.\n\nThe `addStakeRefs` function takes a stake object as input and adds appropriate reference keys to the storage. The reference keys are created based on the stake object's owner, staked coins, and start time. The function first calls the `getStakeRefKeys` function to get the reference keys for the stake object. It then iterates over the reference keys and adds them to the storage using the `addRefByKey` function. The `addRefByKey` function is not defined in this file, but it is likely defined in another file in the `keeper` package.\n\nThe `deleteStakeRefs` function is similar to the `addStakeRefs` function, but it deletes the reference keys for a given stake object instead of adding them. It first calls the `getStakeRefKeys` function to get the reference keys for the stake object. It then iterates over the reference keys and deletes them from the storage using the `deleteRefByKey` function. The `deleteRefByKey` function is not defined in this file, but it is likely defined in another file in the `keeper` package.\n\nThe `getStakeRefKeys` function is used by both `addStakeRefs` and `deleteStakeRefs` functions to generate the reference keys for a given stake object. The function takes a stake object as input and returns a slice of byte slices representing the reference keys. The function first converts the stake object's owner address from a Bech32 string to a byte slice using the `sdk.AccAddressFromBech32` function. It then creates a slice of byte slices representing the reference keys based on the staked coins and start time. The reference keys are created using the `CombineKeys` function, which concatenates the input byte slices with a separator byte. The reference keys are then returned as a slice of byte slices.\n\nOverall, these functions are used to manage the reference keys for staked assets in the Duality project. They are likely used in conjunction with other functions in the `keeper` package to calculate and distribute incentives to stakers. Here is an example of how the `addStakeRefs` function might be used in the larger project:\n\n```\n// create a new stake object\nstake := types.Stake{\n    ID:        \"1\",\n    Owner:     \"cosmos1abc...\",\n    Coins:     sdk.NewCoins(sdk.NewCoin(\"abc\", sdk.NewInt(100))),\n    StartTime: time.Now(),\n}\n\n// add the reference keys for the stake object\nerr := keeper.addStakeRefs(ctx, &stake)\nif err != nil {\n    panic(err)\n}\n```",
      "questions": "1. What is the purpose of the `addStakeRefs` and `deleteStakeRefs` functions?\n   - These functions add and delete reference keys for a stake, respectively. The reference keys are used to keep track of the stake in various contexts.\n2. What is the `getStakeRefKeys` function doing?\n   - This function generates a list of reference keys for a given stake. The keys are used to index the stake in various contexts.\n3. What external packages are being imported in this file?\n   - This file imports `github.com/cosmos/cosmos-sdk/types`, `github.com/duality-labs/duality/x/dex/types`, and `github.com/duality-labs/duality/x/incentives/types`."
    },
    {
      "fileName": "msg_server.go",
      "filePath": "x/incentives/keeper/msg_server.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/msg_server.go",
      "summary": "The `keeper` package contains the implementation of the message server interface for the incentives module of the Duality project. The `msgServer` struct provides a way to reference the `Keeper` pointer in the message server interface. The `NewMsgServerImpl` function returns an instance of `MsgServer` for the provided `Keeper`.\n\nThe `CreateGauge` function creates a new gauge and sends coins to the gauge. It emits a create gauge event and returns the create gauge response. The function takes in a context, a message of type `MsgCreateGauge`, and returns a message of type `MsgCreateGaugeResponse`. The `AddToGauge` function adds coins to an existing gauge. It emits an add to gauge event and returns the add to gauge response. The function takes in a context, a message of type `MsgAddToGauge`, and returns a message of type `MsgAddToGaugeResponse`.\n\nThe `Stake` function stakes tokens in either of two ways. It either adds to an existing stake if a stake with the same owner and same duration exists or creates a new stake if not. A sanity check to ensure that the given tokens are a single token is done in `ValidateBasic`. That is, a stake with multiple tokens cannot be created. The function takes in a context, a message of type `MsgStake`, and returns a message of type `MsgStakeResponse`.\n\nThe `Unstake` function begins the unstaking of the specified stake. The stake would enter the unstaking queue, with the end time of the stake set as block time + duration. The function takes in a context, a message of type `MsgUnstake`, and returns a message of type `MsgUnstakeResponse`.\n\nOverall, this package provides the implementation of the message server interface for the incentives module of the Duality project. It allows for the creation and management of gauges and stakes, which are used to incentivize users to participate in the network.",
      "questions": "1. What is the purpose of the `keeper` package and what other packages does it import?\n- The `keeper` package appears to be part of the `duality` project and it imports packages from `github.com/duality-labs/duality/x/incentives/types` and `github.com/cosmos/cosmos-sdk/types`.\n2. What is the purpose of the `msgServer` struct and its associated methods?\n- The `msgServer` struct provides a way to reference the `keeper` pointer in the message server interface. Its associated methods (`CreateGauge`, `AddToGauge`, `Stake`, and `Unstake`) perform various actions related to creating and managing gauges, adding rewards to gauges, staking tokens, and beginning the unstaking process.\n3. What types of events are emitted by the `msgServer` methods?\n- The `CreateGauge` method emits a `TypeEvtCreateGauge` event with an attribute for the gauge ID. The `AddToGauge` method emits a `TypeEvtAddToGauge` event with an attribute for the gauge ID. The `Stake` method emits a `TypeEvtStake` event with attributes for the stake ID, owner, and amount. The `Unstake` method does not emit an event directly, but instead emits a `TypeEvtBeginUnstake` event downstream in the keeper method."
    },
    {
      "fileName": "params.go",
      "filePath": "x/incentives/keeper/params.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/params.go",
      "summary": "The code above is a part of the `duality` project and is located in the `keeper` package. The purpose of this code is to define two functions that allow for getting and setting parameters in the incentive module. \n\nThe `GetParams` function takes in a `sdk.Context` object and returns a `types.Params` object. This function retrieves all of the parameters in the incentive module by calling the `GetParamSet` function on the `paramSpace` object. The `GetParamSet` function takes in a `sdk.Context` object and a pointer to a `types.Params` object and sets the `params` object to the current parameter set. The `GetParams` function then returns the `params` object.\n\nThe `SetParams` function takes in a `sdk.Context` object and a `types.Params` object. This function sets all of the parameters in the incentive module by calling the `SetParamSet` function on the `paramSpace` object. The `SetParamSet` function takes in a `sdk.Context` object and a pointer to a `types.Params` object and sets the current parameter set to the `params` object passed in.\n\nThese functions are important for the larger `duality` project because they allow for the manipulation of parameters in the incentive module. This can be useful for adjusting the incentives offered to users of the platform or for changing the rules around how incentives are earned. \n\nHere is an example of how these functions might be used in the larger `duality` project:\n\n```\n// create a new context object\nctx := sdk.NewContext(...)\n\n// create a new keeper object\nkeeper := NewKeeper(...)\n\n// get the current parameters\nparams := keeper.GetParams(ctx)\n\n// adjust the incentive parameters\nparams.IncentiveAmount = sdk.NewInt(1000)\nparams.IncentiveDuration = time.Hour * 24 * 7\n\n// set the new parameters\nkeeper.SetParams(ctx, params)\n```\n\nIn this example, we create a new context object and a new keeper object. We then use the `GetParams` function to retrieve the current parameters and adjust them as needed. Finally, we use the `SetParams` function to set the new parameters. This allows us to adjust the incentives offered to users of the platform and change the rules around how incentives are earned.",
      "questions": "1. What is the purpose of the `incentives` package imported from `github.com/duality-labs/duality/x/incentives/types`?\n- The `incentives` package likely contains types and functions related to incentivizing certain behaviors within the duality project.\n\n2. What is the `paramSpace` variable used for in the `GetParams` and `SetParams` functions?\n- The `paramSpace` variable is likely a parameter space object that allows for the storage and retrieval of module-specific parameters.\n\n3. What is the expected behavior if `SetParams` is called with an empty `params` argument?\n- It is unclear from the code what the expected behavior would be if `SetParams` is called with an empty `params` argument. This would be a good question to clarify with the developer or documentation."
    },
    {
      "fileName": "query_server.go",
      "filePath": "x/incentives/keeper/query_server.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/query_server.go",
      "summary": "The `keeper` package contains the implementation of the QueryServer struct, which provides gRPC method handlers for the incentives module keeper. The QueryServer struct wraps around the incentives module keeper and provides methods to query the status of the module, gauges, stakes, and future reward estimates.\n\nThe `GetModuleStatus` method returns the reward coins, staked coins, and parameters of the incentives module. The `GetGaugeByID` method returns the gauge with the given ID. The `GetGauges` method returns a list of gauges filtered by status, denomination, and pagination. The `GetStakeByID` method returns the stake with the given ID. The `GetStakes` method returns a list of stakes for a given owner. The `GetFutureRewardEstimate` method returns an estimate of the future rewards for a given owner and stakes.\n\nThe `filterByPrefixAndDenom` method filters gauges based on a given key prefix and denomination. The method takes a context, key prefix, denomination, and pagination as input parameters. It returns a page response, a list of gauges, and an error. The method filters the gauges based on the denomination and key prefix. If the denomination is not empty, the method filters the gauges based on the denomination and the tick range. If the denomination is empty, the method returns all gauges.\n\nThe `getGaugeFromIDJsonBytes` method returns gauges from the JSON bytes of gauge IDs. The method takes a context and a byte array as input parameters. It returns a list of gauges and an error. The method unmarshals the byte array into a list of gauge IDs and retrieves the gauges with the given IDs.\n\nThe QueryServer struct is created by calling the `NewQueryServer` function, which takes a keeper as an input parameter. The keeper is an instance of the incentives module keeper. The QueryServer struct implements the `types.QueryServer` interface, which defines the gRPC methods for the incentives module.\n\nOverall, the QueryServer struct provides a set of methods to query the status of the incentives module, gauges, stakes, and future reward estimates. These methods can be used by other modules in the duality project to interact with the incentives module.",
      "questions": "1. What is the purpose of the `duality` project and how does this code file fit into it?\n- The code file is a part of the `keeper` package in the `duality` project, which suggests that it is related to the storage and management of data within the project. However, more information is needed to determine the overall purpose of the project.\n\n2. What are the inputs and outputs of the `GetFutureRewardEstimate` function?\n- The `GetFutureRewardEstimate` function takes in a request object that includes an owner address and a list of stake IDs, as well as an end epoch value. It returns a response object that includes an estimate of the future rewards for the specified owner and stakes.\n\n3. What is the purpose of the `filterByPrefixAndDenom` function and how does it work?\n- The `filterByPrefixAndDenom` function filters gauges based on a given key prefix and denom. It works by retrieving gauges from the store that match the prefix and then filtering them based on the denom value. The function returns a page response object and a list of gauges that match the filter criteria."
    },
    {
      "fileName": "stake.go",
      "filePath": "x/incentives/keeper/stake.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/stake.go",
      "summary": "The `keeper` package contains the implementation of the `Keeper` struct, which is responsible for managing the state of the `incentives` module in the `duality` project. The `Keeper` struct provides several methods for interacting with the state of the module, including `GetLastStakeID`, `SetLastStakeID`, `Stake`, `Unstake`, `setStake`, `deleteStake`, `GetStakeByID`, `GetStakesByQueryCondition`, `GetStakes`, `getStakesByAccount`, and `CreateStake`.\n\nThe `GetLastStakeID` method retrieves the ID used last time from the key-value store associated with the `incentives` module. The `SetLastStakeID` method saves the ID used by the last stake to the key-value store. The `Stake` method is an internal utility that stakes coins and sets corresponding states. This method is only called by either of the two possible entry points to stake tokens: `CreateStake` and `AddTokensToStakeByID`. The `Unstake` method is used to unstake tokens and remove the corresponding stake object from the state. The `setStake` method is a utility to store a stake object into the store. The `deleteStake` method removes the stake object from the state. The `GetStakeByID` method returns a stake from a stake ID. The `GetStakesByQueryCondition` method returns the period locks associated with an account based on a query condition. The `GetStakes` method returns all the period locks in the state. The `getStakesByAccount` method returns the period locks associated with an account. The `CreateStake` method creates a new stake object and stores it in the state.\n\nOverall, the `keeper` package provides a set of methods for managing the state of the `incentives` module in the `duality` project. These methods can be used to stake and unstake tokens, retrieve stake objects from the state, and manage the period locks associated with an account.",
      "questions": "1. What is the purpose of the `Stake` function and when is it called?\n- The `Stake` function is an internal utility to stake coins and set corresponding states. It is called by either of the two possible entry points to stake tokens: `CreateStake` and `AddTokensToStakeByID`.\n\n2. What is the difference between `GetStakes` and `GetStakesByAccount` functions?\n- The `GetStakes` function returns all period locks, while the `GetStakesByAccount` function returns the period locks associated with a specific account.\n\n3. What is the purpose of the `setStake` function?\n- The `setStake` function is a utility to store a stake object into the store. It takes a `Keeper` and a `Stake` object as input, and stores the object in the key-value store associated with the `Keeper`."
    },
    {
      "fileName": "utils.go",
      "filePath": "x/incentives/keeper/utils.go",
      "url": "https://github.com/duality-labs/duality/incentives/keeper/utils.go",
      "summary": "The `keeper` package contains functions for managing references to objects in the `duality` project. The package provides methods for adding, deleting, and retrieving references to objects using Cosmos SDK's `KVStore`.\n\nThe `findIndex` function takes an array of IDs and a specific ID, then returns the index of the specific ID in the array. If the ID is not found, it returns -1.\n\nThe `removeValue` function takes an array of IDs and a specific ID, then finds the index of the ID in the array and removes it. It returns the updated array and the index of the removed ID. If the ID is not found, it returns the original array and -1.\n\nThe `getRefs` method takes a context and a key, then retrieves the IDs associated with the key from the KVStore. It returns an array of IDs.\n\nThe `addRefByKey` method takes a context, a key, and an ID, then appends the ID to the array associated with the key in the KVStore. It first retrieves the existing IDs associated with the key, checks if the ID already exists in the array, and returns an error if it does. If the ID does not exist, it appends the ID to the array and stores the updated array in the KVStore.\n\nThe `deleteRefByKey` method takes a context, a key, and an ID, then removes the ID from the array associated with the key in the KVStore. It first retrieves the existing IDs associated with the key, removes the ID from the array, and returns an error if the ID is not found. If the ID is found and removed, it updates the array in the KVStore. If the array is empty after the ID is removed, it deletes the key from the KVStore.\n\nThese functions and methods can be used to manage references to objects in the `duality` project. For example, `addRefByKey` can be used to add a reference to an object when it is created, and `deleteRefByKey` can be used to remove the reference when the object is deleted. The `getRefs` method can be used to retrieve all references associated with a specific key.",
      "questions": "1. What is the purpose of the `Keeper` type and where is it defined?\n- The `Keeper` type is used in the `getRefs`, `addRefByKey`, and `deleteRefByKey` functions to interact with the key-value store. It is likely defined in another file within the `duality` project.\n\n2. What is the expected format of the `key` parameter in the `getRefs`, `addRefByKey`, and `deleteRefByKey` functions?\n- The `key` parameter is expected to be a byte slice that is used to identify the array of IDs associated with a particular object.\n\n3. What happens if an error occurs during JSON unmarshaling in the `getRefs` function?\n- If an error occurs during JSON unmarshaling, the function will panic."
    }
  ],
  "folders": [],
  "summary": "The `keeper` package in the `incentives` module of the Duality project is responsible for managing the state and providing functions for creating, modifying, and retrieving gauges and stakes. Gauges are used to distribute rewards to users based on certain conditions, while stakes represent the tokens locked by users to participate in the network.\n\nFor example, the `gauge.go` file provides functions to create, modify, and retrieve gauges. The `CreateGauge` function creates a gauge and sends coins to it, while the `AddToGaugeRewards` function adds coins to an existing gauge. The `GetGauges` function returns upcoming, active, and finished gauges, which can be used to manage the distribution of rewards to users.\n\nThe `genesis.go` file initializes and exports the state of the incentives module, which is crucial for managing the incentives and rewards for users who participate in the network. The `InitializeAllStakes` and `InitializeAllGauges` functions are used to set the state of the stakes and gauges, respectively.\n\nThe `hooks.go` file defines hooks that are called at the start and end of each epoch in the Duality blockchain. These hooks are used to perform actions related to distributing rewards to users. The `AfterEpochEnd` hook retrieves and distributes rewards to users based on the active gauges.\n\nThe `invariants.go` file registers and executes invariants for the governance module, ensuring the integrity of the system. The `AccumulationStoreInvariant` and `StakesBalancesInvariant` functions are used to detect and prevent errors in the system, which could lead to incorrect calculations or other issues.\n\nThe `iterator.go` file provides functions to manage the state of the incentives module, including retrieving and manipulating data stored in the key-value store. The `getStakesFromIterator` function retrieves stakes from the key-value store and returns them as an array.\n\nThe `keeper.go` file defines the `Keeper` struct, which manages the storage of the incentives module. The `GetModuleBalance` and `GetModuleStakedCoins` functions return the full balance and staked balance of the module, respectively.\n\nThe `lock_refs.go` file provides functions to manage reference keys for staked assets. The `addStakeRefs` and `deleteStakeRefs` functions are used to add and delete reference keys for a given stake, which are used to track the staked assets and calculate the incentives that should be rewarded to the staker.\n\nThe `msg_server.go` file implements the message server interface for the incentives module, allowing for the creation and management of gauges and stakes. The `Stake` and `Unstake` functions are used to stake and unstake tokens, respectively.\n\nThe `params.go` file provides functions to get and set parameters in the incentive module, which can be useful for adjusting the incentives offered to users or changing the rules around how incentives are earned.\n\nThe `query_server.go` file implements the QueryServer struct, which provides gRPC method handlers for querying the status of the module, gauges, stakes, and future reward estimates.\n\nThe `stake.go` file provides methods for managing stakes, such as `CreateStake`, which creates a new stake object and stores it in the state.\n\nThe `utils.go` file contains functions for managing references to objects in the Duality project, such as `addRefByKey` and `deleteRefByKey`, which can be used to manage references to objects when they are created or deleted.\n\nExample usage of the `keeper` package might involve creating a new gauge, staking tokens, and retrieving the active gauges to distribute rewards to users:\n\n```go\n// create a new gauge\nkeeper.CreateGauge(ctx, ...)\n\n// stake tokens\nkeeper.Stake(ctx, ...)\n\n// get active gauges\nactiveGauges := keeper.GetActiveGauges(ctx)\n```",
  "questions": ""
}