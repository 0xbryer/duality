# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cosmos/nft/v1beta1/event.proto, cosmos/nft/v1beta1/genesis.proto, cosmos/nft/v1beta1/nft.proto, cosmos/nft/v1beta1/query.proto, cosmos/nft/v1beta1/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class MsgSend(betterproto.Message):
    """
    MsgSend represents a message to send a nft from one account to another
    account.
    """

    # class_id defines the unique identifier of the nft classification, similar
    # to the contract address of ERC721
    class_id: str = betterproto.string_field(1)
    # id defines the unique identification of nft
    id: str = betterproto.string_field(2)
    # sender is the address of the owner of nft
    sender: str = betterproto.string_field(3)
    # receiver is the receiver address of nft
    receiver: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgSendResponse(betterproto.Message):
    """MsgSendResponse defines the Msg/Send response type."""

    pass


@dataclass(eq=False, repr=False)
class Class(betterproto.Message):
    """Class defines the class of the nft type."""

    # id defines the unique identifier of the NFT classification, similar to the
    # contract address of ERC721
    id: str = betterproto.string_field(1)
    # name defines the human-readable name of the NFT classification. Optional
    name: str = betterproto.string_field(2)
    # symbol is an abbreviated name for nft classification. Optional
    symbol: str = betterproto.string_field(3)
    # description is a brief description of nft classification. Optional
    description: str = betterproto.string_field(4)
    # uri for the class metadata stored off chain. It can define schema for Class
    # and NFT `Data` attributes. Optional
    uri: str = betterproto.string_field(5)
    # uri_hash is a hash of the document pointed by uri. Optional
    uri_hash: str = betterproto.string_field(6)
    # data is the app specific metadata of the NFT class. Optional
    data: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class Nft(betterproto.Message):
    """NFT defines the NFT."""

    # class_id associated with the NFT, similar to the contract address of ERC721
    class_id: str = betterproto.string_field(1)
    # id is a unique identifier of the NFT
    id: str = betterproto.string_field(2)
    # uri for the NFT metadata stored off chain
    uri: str = betterproto.string_field(3)
    # uri_hash is a hash of the document pointed by uri
    uri_hash: str = betterproto.string_field(4)
    # data is an app specific data of the NFT. Optional
    data: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the nft module's genesis state."""

    # class defines the class of the nft type.
    classes: List["Class"] = betterproto.message_field(1)
    entries: List["Entry"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Entry(betterproto.Message):
    """Entry Defines all nft owned by a person"""

    # owner is the owner address of the following nft
    owner: str = betterproto.string_field(1)
    # nfts is a group of nfts of the same owner
    nfts: List["Nft"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EventSend(betterproto.Message):
    """EventSend is emitted on Msg/Send"""

    class_id: str = betterproto.string_field(1)
    id: str = betterproto.string_field(2)
    sender: str = betterproto.string_field(3)
    receiver: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class EventMint(betterproto.Message):
    """EventMint is emitted on Mint"""

    class_id: str = betterproto.string_field(1)
    id: str = betterproto.string_field(2)
    owner: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class EventBurn(betterproto.Message):
    """EventBurn is emitted on Burn"""

    class_id: str = betterproto.string_field(1)
    id: str = betterproto.string_field(2)
    owner: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class QueryBalanceRequest(betterproto.Message):
    """
    QueryBalanceRequest is the request type for the Query/Balance RPC method
    """

    class_id: str = betterproto.string_field(1)
    owner: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryBalanceResponse(betterproto.Message):
    """
    QueryBalanceResponse is the response type for the Query/Balance RPC method
    """

    amount: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryOwnerRequest(betterproto.Message):
    """QueryOwnerRequest is the request type for the Query/Owner RPC method"""

    class_id: str = betterproto.string_field(1)
    id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryOwnerResponse(betterproto.Message):
    """
    QueryOwnerResponse is the response type for the Query/Owner RPC method
    """

    owner: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QuerySupplyRequest(betterproto.Message):
    """
    QuerySupplyRequest is the request type for the Query/Supply RPC method
    """

    class_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QuerySupplyResponse(betterproto.Message):
    """
    QuerySupplyResponse is the response type for the Query/Supply RPC method
    """

    amount: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryNfTsRequest(betterproto.Message):
    """QueryNFTstRequest is the request type for the Query/NFTs RPC method"""

    class_id: str = betterproto.string_field(1)
    owner: str = betterproto.string_field(2)
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class QueryNfTsResponse(betterproto.Message):
    """
    QueryNFTsResponse is the response type for the Query/NFTs RPC methods
    """

    nfts: List["Nft"] = betterproto.message_field(1)
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryNftRequest(betterproto.Message):
    """QueryNFTRequest is the request type for the Query/NFT RPC method"""

    class_id: str = betterproto.string_field(1)
    id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryNftResponse(betterproto.Message):
    """QueryNFTResponse is the response type for the Query/NFT RPC method"""

    nft: "Nft" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryClassRequest(betterproto.Message):
    """QueryClassRequest is the request type for the Query/Class RPC method"""

    class_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryClassResponse(betterproto.Message):
    """
    QueryClassResponse is the response type for the Query/Class RPC method
    """

    class_: "Class" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryClassesRequest(betterproto.Message):
    """
    QueryClassesRequest is the request type for the Query/Classes RPC method
    """

    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryClassesResponse(betterproto.Message):
    """
    QueryClassesResponse is the response type for the Query/Classes RPC method
    """

    classes: List["Class"] = betterproto.message_field(1)
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


class MsgStub(betterproto.ServiceStub):
    async def send(
        self, *, class_id: str = "", id: str = "", sender: str = "", receiver: str = ""
    ) -> "MsgSendResponse":

        request = MsgSend()
        request.class_id = class_id
        request.id = id
        request.sender = sender
        request.receiver = receiver

        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Msg/Send", request, MsgSendResponse
        )


class QueryStub(betterproto.ServiceStub):
    async def balance(
        self, *, class_id: str = "", owner: str = ""
    ) -> "QueryBalanceResponse":

        request = QueryBalanceRequest()
        request.class_id = class_id
        request.owner = owner

        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Balance", request, QueryBalanceResponse
        )

    async def owner(self, *, class_id: str = "", id: str = "") -> "QueryOwnerResponse":

        request = QueryOwnerRequest()
        request.class_id = class_id
        request.id = id

        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Owner", request, QueryOwnerResponse
        )

    async def supply(self, *, class_id: str = "") -> "QuerySupplyResponse":

        request = QuerySupplyRequest()
        request.class_id = class_id

        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Supply", request, QuerySupplyResponse
        )

    async def nf_ts(self) -> "QueryNfTsResponse":

        request = QueryNfTsRequest()

        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/NFTs", request, QueryNfTsResponse
        )

    async def nft(self) -> "QueryNftResponse":

        request = QueryNftRequest()

        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/NFT", request, QueryNftResponse
        )

    async def class_(self, *, class_id: str = "") -> "QueryClassResponse":

        request = QueryClassRequest()
        request.class_id = class_id

        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Class", request, QueryClassResponse
        )

    async def classes(
        self, *, pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryClassesResponse":

        request = QueryClassesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.nft.v1beta1.Query/Classes", request, QueryClassesResponse
        )


class MsgBase(ServiceBase):
    async def send(
        self, class_id: str, id: str, sender: str, receiver: str
    ) -> "MsgSendResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_send(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "class_id": request.class_id,
            "id": request.id,
            "sender": request.sender,
            "receiver": request.receiver,
        }

        response = await self.send(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.nft.v1beta1.Msg/Send": grpclib.const.Handler(
                self.__rpc_send,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSend,
                MsgSendResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def balance(self, class_id: str, owner: str) -> "QueryBalanceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def owner(self, class_id: str, id: str) -> "QueryOwnerResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def supply(self, class_id: str) -> "QuerySupplyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def nf_ts(self) -> "QueryNfTsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def nft(self) -> "QueryNftResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def class_(self, class_id: str) -> "QueryClassResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def classes(
        self, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryClassesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_balance(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "class_id": request.class_id,
            "owner": request.owner,
        }

        response = await self.balance(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_owner(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "class_id": request.class_id,
            "id": request.id,
        }

        response = await self.owner(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_supply(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "class_id": request.class_id,
        }

        response = await self.supply(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_nf_ts(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.nf_ts(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_nft(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.nft(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_class_(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "class_id": request.class_id,
        }

        response = await self.class_(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_classes(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.classes(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.nft.v1beta1.Query/Balance": grpclib.const.Handler(
                self.__rpc_balance,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryBalanceRequest,
                QueryBalanceResponse,
            ),
            "/cosmos.nft.v1beta1.Query/Owner": grpclib.const.Handler(
                self.__rpc_owner,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryOwnerRequest,
                QueryOwnerResponse,
            ),
            "/cosmos.nft.v1beta1.Query/Supply": grpclib.const.Handler(
                self.__rpc_supply,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySupplyRequest,
                QuerySupplyResponse,
            ),
            "/cosmos.nft.v1beta1.Query/NFTs": grpclib.const.Handler(
                self.__rpc_nf_ts,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNfTsRequest,
                QueryNfTsResponse,
            ),
            "/cosmos.nft.v1beta1.Query/NFT": grpclib.const.Handler(
                self.__rpc_nft,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNftRequest,
                QueryNftResponse,
            ),
            "/cosmos.nft.v1beta1.Query/Class": grpclib.const.Handler(
                self.__rpc_class_,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryClassRequest,
                QueryClassResponse,
            ),
            "/cosmos.nft.v1beta1.Query/Classes": grpclib.const.Handler(
                self.__rpc_classes,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryClassesRequest,
                QueryClassesResponse,
            ),
        }


from ...base.query import v1beta1 as __base_query_v1_beta1__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
