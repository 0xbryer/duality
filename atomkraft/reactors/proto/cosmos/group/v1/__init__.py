# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cosmos/group/v1/events.proto, cosmos/group/v1/genesis.proto, cosmos/group/v1/query.proto, cosmos/group/v1/tx.proto, cosmos/group/v1/types.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class VoteOption(betterproto.Enum):
    """VoteOption enumerates the valid vote options for a given proposal."""

    # VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
    VOTE_OPTION_UNSPECIFIED = 0
    # VOTE_OPTION_YES defines a yes vote option.
    VOTE_OPTION_YES = 1
    # VOTE_OPTION_ABSTAIN defines an abstain vote option.
    VOTE_OPTION_ABSTAIN = 2
    # VOTE_OPTION_NO defines a no vote option.
    VOTE_OPTION_NO = 3
    # VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
    VOTE_OPTION_NO_WITH_VETO = 4


class ProposalStatus(betterproto.Enum):
    """ProposalStatus defines proposal statuses."""

    # An empty value is invalid and not allowed.
    PROPOSAL_STATUS_UNSPECIFIED = 0
    # Initial status of a proposal when persisted.
    PROPOSAL_STATUS_SUBMITTED = 1
    # Final status of a proposal when the final tally was executed.
    PROPOSAL_STATUS_CLOSED = 2
    # Final status of a proposal when the group was modified before the final
    # tally.
    PROPOSAL_STATUS_ABORTED = 3
    # A proposal can be deleted before the voting start time by the owner. When
    # this happens the final status is Withdrawn.
    PROPOSAL_STATUS_WITHDRAWN = 4


class ProposalResult(betterproto.Enum):
    """ProposalResult defines types of proposal results."""

    # An empty value is invalid and not allowed
    PROPOSAL_RESULT_UNSPECIFIED = 0
    # Until a final tally has happened the status is unfinalized
    PROPOSAL_RESULT_UNFINALIZED = 1
    # Final result of the tally
    PROPOSAL_RESULT_ACCEPTED = 2
    # Final result of the tally
    PROPOSAL_RESULT_REJECTED = 3


class ProposalExecutorResult(betterproto.Enum):
    """ProposalExecutorResult defines types of proposal executor results."""

    # An empty value is not allowed.
    PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0
    # We have not yet run the executor.
    PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1
    # The executor was successful and proposed action updated state.
    PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2
    # The executor returned an error and proposed action didn't update state.
    PROPOSAL_EXECUTOR_RESULT_FAILURE = 3


class Exec(betterproto.Enum):
    """
    Exec defines modes of execution of a proposal on creation or on new vote.
    """

    # An empty value means that there should be a separate MsgExec request for
    # the proposal to execute.
    EXEC_UNSPECIFIED = 0
    # Try to execute the proposal immediately. If the proposal is not allowed per
    # the DecisionPolicy, the proposal will still be open and could be executed
    # at a later point.
    EXEC_TRY = 1


@dataclass(eq=False, repr=False)
class Member(betterproto.Message):
    """
    Member represents a group member with an account address, non-zero weight
    and metadata.
    """

    # address is the member's account address.
    address: str = betterproto.string_field(1)
    # weight is the member's voting weight that should be greater than 0.
    weight: str = betterproto.string_field(2)
    # metadata is any arbitrary metadata to attached to the member.
    metadata: str = betterproto.string_field(3)
    # added_at is a timestamp specifying when a member was added.
    added_at: datetime = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class Members(betterproto.Message):
    """Members defines a repeated slice of Member objects."""

    # members is the list of members.
    members: List["Member"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ThresholdDecisionPolicy(betterproto.Message):
    """ThresholdDecisionPolicy implements the DecisionPolicy interface"""

    # threshold is the minimum weighted sum of yes votes that must be met or
    # exceeded for a proposal to succeed.
    threshold: str = betterproto.string_field(1)
    # windows defines the different windows for voting and execution.
    windows: "DecisionPolicyWindows" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class PercentageDecisionPolicy(betterproto.Message):
    """PercentageDecisionPolicy implements the DecisionPolicy interface"""

    # percentage is the minimum percentage the weighted sum of yes votes must
    # meet for a proposal to succeed.
    percentage: str = betterproto.string_field(1)
    # windows defines the different windows for voting and execution.
    windows: "DecisionPolicyWindows" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class DecisionPolicyWindows(betterproto.Message):
    """
    DecisionPolicyWindows defines the different windows for voting and
    execution.
    """

    # voting_period is the duration from submission of a proposal to the end of
    # voting period Within this times votes can be submitted with MsgVote.
    voting_period: timedelta = betterproto.message_field(1)
    # min_execution_period is the minimum duration after the proposal submission
    # where members can start sending MsgExec. This means that the window for
    # sending a MsgExec transaction is: `[ submission + min_execution_period ;
    # submission + voting_period + max_execution_period]` where
    # max_execution_period is a app-specific config, defined in the keeper. If
    # not set, min_execution_period will default to 0. Please make sure to set a
    # `min_execution_period` that is smaller than `voting_period +
    # max_execution_period`, or else the above execution window is empty, meaning
    # that all proposals created with this decision policy won't be able to be
    # executed.
    min_execution_period: timedelta = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class GroupInfo(betterproto.Message):
    """
    GroupInfo represents the high-level on-chain information for a group.
    """

    # id is the unique ID of the group.
    id: int = betterproto.uint64_field(1)
    # admin is the account address of the group's admin.
    admin: str = betterproto.string_field(2)
    # metadata is any arbitrary metadata to attached to the group.
    metadata: str = betterproto.string_field(3)
    # version is used to track changes to a group's membership structure that
    # would break existing proposals. Whenever any members weight is changed, or
    # any member is added or removed this version is incremented and will cause
    # proposals based on older versions of this group to fail
    version: int = betterproto.uint64_field(4)
    # total_weight is the sum of the group members' weights.
    total_weight: str = betterproto.string_field(5)
    # created_at is a timestamp specifying when a group was created.
    created_at: datetime = betterproto.message_field(6)


@dataclass(eq=False, repr=False)
class GroupMember(betterproto.Message):
    """
    GroupMember represents the relationship between a group and a member.
    """

    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(1)
    # member is the member data.
    member: "Member" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class GroupPolicyInfo(betterproto.Message):
    """
    GroupPolicyInfo represents the high-level on-chain information for a group
    policy.
    """

    # address is the account address of group policy.
    address: str = betterproto.string_field(1)
    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(2)
    # admin is the account address of the group admin.
    admin: str = betterproto.string_field(3)
    # metadata is any arbitrary metadata to attached to the group policy.
    metadata: str = betterproto.string_field(4)
    # version is used to track changes to a group's GroupPolicyInfo structure
    # that would create a different result on a running proposal.
    version: int = betterproto.uint64_field(5)
    # decision_policy specifies the group policy's decision policy.
    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        6
    )
    # created_at is a timestamp specifying when a group policy was created.
    created_at: datetime = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class Proposal(betterproto.Message):
    """
    Proposal defines a group proposal. Any member of a group can submit a
    proposal for a group policy to decide upon. A proposal consists of a set of
    `sdk.Msg`s that will be executed if the proposal passes as well as some
    optional metadata associated with the proposal.
    """

    # id is the unique id of the proposal.
    id: int = betterproto.uint64_field(1)
    # address is the account address of group policy.
    address: str = betterproto.string_field(2)
    # metadata is any arbitrary metadata to attached to the proposal.
    metadata: str = betterproto.string_field(3)
    # proposers are the account addresses of the proposers.
    proposers: List[str] = betterproto.string_field(4)
    # submit_time is a timestamp specifying when a proposal was submitted.
    submit_time: datetime = betterproto.message_field(5)
    # group_version tracks the version of the group that this proposal
    # corresponds to. When group membership is changed, existing proposals from
    # previous group versions will become invalid.
    group_version: int = betterproto.uint64_field(6)
    # group_policy_version tracks the version of the group policy that this
    # proposal corresponds to. When a decision policy is changed, existing
    # proposals from previous policy versions will become invalid.
    group_policy_version: int = betterproto.uint64_field(7)
    # status represents the high level position in the life cycle of the
    # proposal. Initial value is Submitted.
    status: "ProposalStatus" = betterproto.enum_field(8)
    # result is the final result based on the votes and election rule. Initial
    # value is unfinalized. The result is persisted so that clients can always
    # rely on this state and not have to replicate the logic.
    result: "ProposalResult" = betterproto.enum_field(9)
    # final_tally_result contains the sums of all weighted votes for this
    # proposal for each vote option, after tallying. When querying a proposal via
    # gRPC, this field is not populated until the proposal's voting period has
    # ended.
    final_tally_result: "TallyResult" = betterproto.message_field(10)
    # voting_period_end is the timestamp before which voting must be done. Unless
    # a successfull MsgExec is called before (to execute a proposal whose tally
    # is successful before the voting period ends), tallying will be done at this
    # point, and the `final_tally_result`, as well as `status` and `result`
    # fields will be accordingly updated.
    voting_period_end: datetime = betterproto.message_field(11)
    # executor_result is the final result based on the votes and election rule.
    # Initial value is NotRun.
    executor_result: "ProposalExecutorResult" = betterproto.enum_field(12)
    # messages is a list of Msgs that will be executed if the proposal passes.
    messages: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(
        13
    )


@dataclass(eq=False, repr=False)
class TallyResult(betterproto.Message):
    """
    TallyResult represents the sum of weighted votes for each vote option.
    """

    # yes_count is the weighted sum of yes votes.
    yes_count: str = betterproto.string_field(1)
    # abstain_count is the weighted sum of abstainers.
    abstain_count: str = betterproto.string_field(2)
    # no is the weighted sum of no votes.
    no_count: str = betterproto.string_field(3)
    # no_with_veto_count is the weighted sum of veto.
    no_with_veto_count: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class Vote(betterproto.Message):
    """Vote represents a vote for a proposal."""

    # proposal is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)
    # voter is the account address of the voter.
    voter: str = betterproto.string_field(2)
    # option is the voter's choice on the proposal.
    option: "VoteOption" = betterproto.enum_field(3)
    # metadata is any arbitrary metadata to attached to the vote.
    metadata: str = betterproto.string_field(4)
    # submit_time is the timestamp when the vote was submitted.
    submit_time: datetime = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class MsgCreateGroup(betterproto.Message):
    """MsgCreateGroup is the Msg/CreateGroup request type."""

    # admin is the account address of the group admin.
    admin: str = betterproto.string_field(1)
    # members defines the group members.
    members: List["Member"] = betterproto.message_field(2)
    # metadata is any arbitrary metadata to attached to the group.
    metadata: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MsgCreateGroupResponse(betterproto.Message):
    """MsgCreateGroupResponse is the Msg/CreateGroup response type."""

    # group_id is the unique ID of the newly created group.
    group_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMembers(betterproto.Message):
    """MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type."""

    # admin is the account address of the group admin.
    admin: str = betterproto.string_field(1)
    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(2)
    # member_updates is the list of members to update, set weight to 0 to remove
    # a member.
    member_updates: List["Member"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMembersResponse(betterproto.Message):
    """
    MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateGroupAdmin(betterproto.Message):
    """MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type."""

    # admin is the current account address of the group admin.
    admin: str = betterproto.string_field(1)
    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(2)
    # new_admin is the group new admin account address.
    new_admin: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MsgUpdateGroupAdminResponse(betterproto.Message):
    """
    MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMetadata(betterproto.Message):
    """MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type."""

    # admin is the account address of the group admin.
    admin: str = betterproto.string_field(1)
    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(2)
    # metadata is the updated group's metadata.
    metadata: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMetadataResponse(betterproto.Message):
    """
    MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response
    type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgCreateGroupPolicy(betterproto.Message):
    """MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type."""

    # admin is the account address of the group admin.
    admin: str = betterproto.string_field(1)
    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(2)
    # metadata is any arbitrary metadata attached to the group policy.
    metadata: str = betterproto.string_field(3)
    # decision_policy specifies the group policy's decision policy.
    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        4
    )


@dataclass(eq=False, repr=False)
class MsgCreateGroupPolicyResponse(betterproto.Message):
    """
    MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
    """

    # address is the account address of the newly created group policy.
    address: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyAdmin(betterproto.Message):
    """
    MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
    """

    # admin is the account address of the group admin.
    admin: str = betterproto.string_field(1)
    # address is the account address of the group policy.
    address: str = betterproto.string_field(2)
    # new_admin is the new group policy admin.
    new_admin: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MsgCreateGroupWithPolicy(betterproto.Message):
    """
    MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
    """

    # admin is the account address of the group and group policy admin.
    admin: str = betterproto.string_field(1)
    # members defines the group members.
    members: List["Member"] = betterproto.message_field(2)
    # group_metadata is any arbitrary metadata attached to the group.
    group_metadata: str = betterproto.string_field(3)
    # group_policy_metadata is any arbitrary metadata attached to the group
    # policy.
    group_policy_metadata: str = betterproto.string_field(4)
    # group_policy_as_admin is a boolean field, if set to true, the group policy
    # account address will be used as group and group policy admin.
    group_policy_as_admin: bool = betterproto.bool_field(5)
    # decision_policy specifies the group policy's decision policy.
    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        6
    )


@dataclass(eq=False, repr=False)
class MsgCreateGroupWithPolicyResponse(betterproto.Message):
    """
    MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response
    type.
    """

    # group_id is the unique ID of the newly created group with policy.
    group_id: int = betterproto.uint64_field(1)
    # group_policy_address is the account address of the newly created group
    # policy.
    group_policy_address: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyAdminResponse(betterproto.Message):
    """
    MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin
    response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyDecisionPolicy(betterproto.Message):
    """
    MsgUpdateGroupPolicyDecisionPolicy is the
    Msg/UpdateGroupPolicyDecisionPolicy request type.
    """

    # admin is the account address of the group admin.
    admin: str = betterproto.string_field(1)
    # address is the account address of group policy.
    address: str = betterproto.string_field(2)
    # decision_policy is the updated group policy's decision policy.
    decision_policy: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        3
    )


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyDecisionPolicyResponse(betterproto.Message):
    """
    MsgUpdateGroupPolicyDecisionPolicyResponse is the
    Msg/UpdateGroupPolicyDecisionPolicy response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyMetadata(betterproto.Message):
    """
    MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request
    type.
    """

    # admin is the account address of the group admin.
    admin: str = betterproto.string_field(1)
    # address is the account address of group policy.
    address: str = betterproto.string_field(2)
    # metadata is the updated group policy metadata.
    metadata: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MsgUpdateGroupPolicyMetadataResponse(betterproto.Message):
    """
    MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata
    response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgSubmitProposal(betterproto.Message):
    """MsgSubmitProposal is the Msg/SubmitProposal request type."""

    # address is the account address of group policy.
    address: str = betterproto.string_field(1)
    # proposers are the account addresses of the proposers. Proposers signatures
    # will be counted as yes votes.
    proposers: List[str] = betterproto.string_field(2)
    # metadata is any arbitrary metadata to attached to the proposal.
    metadata: str = betterproto.string_field(3)
    # messages is a list of `sdk.Msg`s that will be executed if the proposal
    # passes.
    messages: List["betterproto_lib_google_protobuf.Any"] = betterproto.message_field(4)
    # exec defines the mode of execution of the proposal, whether it should be
    # executed immediately on creation or not. If so, proposers signatures are
    # considered as Yes votes.
    exec: "Exec" = betterproto.enum_field(5)


@dataclass(eq=False, repr=False)
class MsgSubmitProposalResponse(betterproto.Message):
    """MsgSubmitProposalResponse is the Msg/SubmitProposal response type."""

    # proposal is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class MsgWithdrawProposal(betterproto.Message):
    """MsgWithdrawProposal is the Msg/WithdrawProposal request type."""

    # proposal is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)
    # address is the admin of the group policy or one of the proposer of the
    # proposal.
    address: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgWithdrawProposalResponse(betterproto.Message):
    """
    MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
    """

    pass


@dataclass(eq=False, repr=False)
class MsgVote(betterproto.Message):
    """MsgVote is the Msg/Vote request type."""

    # proposal is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)
    # voter is the voter account address.
    voter: str = betterproto.string_field(2)
    # option is the voter's choice on the proposal.
    option: "VoteOption" = betterproto.enum_field(3)
    # metadata is any arbitrary metadata to attached to the vote.
    metadata: str = betterproto.string_field(4)
    # exec defines whether the proposal should be executed immediately after
    # voting or not.
    exec: "Exec" = betterproto.enum_field(5)


@dataclass(eq=False, repr=False)
class MsgVoteResponse(betterproto.Message):
    """MsgVoteResponse is the Msg/Vote response type."""

    pass


@dataclass(eq=False, repr=False)
class MsgExec(betterproto.Message):
    """MsgExec is the Msg/Exec request type."""

    # proposal is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)
    # signer is the account address used to execute the proposal.
    signer: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgExecResponse(betterproto.Message):
    """MsgExecResponse is the Msg/Exec request type."""

    pass


@dataclass(eq=False, repr=False)
class MsgLeaveGroup(betterproto.Message):
    """MsgLeaveGroup is the Msg/LeaveGroup request type."""

    # address is the account address of the group member.
    address: str = betterproto.string_field(1)
    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class MsgLeaveGroupResponse(betterproto.Message):
    """MsgLeaveGroupResponse is the Msg/LeaveGroup response type."""

    pass


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the group module's genesis state."""

    # group_seq is the group table orm.Sequence, it is used to get the next group
    # ID.
    group_seq: int = betterproto.uint64_field(1)
    # groups is the list of groups info.
    groups: List["GroupInfo"] = betterproto.message_field(2)
    # group_members is the list of groups members.
    group_members: List["GroupMember"] = betterproto.message_field(3)
    # group_policy_seq is the group policy table orm.Sequence, it is used to
    # generate the next group policy account address.
    group_policy_seq: int = betterproto.uint64_field(4)
    # group_policies is the list of group policies info.
    group_policies: List["GroupPolicyInfo"] = betterproto.message_field(5)
    # proposal_seq is the proposal table orm.Sequence, it is used to get the next
    # proposal ID.
    proposal_seq: int = betterproto.uint64_field(6)
    # proposals is the list of proposals.
    proposals: List["Proposal"] = betterproto.message_field(7)
    # votes is the list of votes.
    votes: List["Vote"] = betterproto.message_field(8)


@dataclass(eq=False, repr=False)
class QueryGroupInfoRequest(betterproto.Message):
    """QueryGroupInfoRequest is the Query/GroupInfo request type."""

    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryGroupInfoResponse(betterproto.Message):
    """QueryGroupInfoResponse is the Query/GroupInfo response type."""

    # info is the GroupInfo for the group.
    info: "GroupInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryGroupPolicyInfoRequest(betterproto.Message):
    """
    QueryGroupPolicyInfoRequest is the Query/GroupPolicyInfo request type.
    """

    # address is the account address of the group policy.
    address: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryGroupPolicyInfoResponse(betterproto.Message):
    """
    QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type.
    """

    # info is the GroupPolicyInfo for the group policy.
    info: "GroupPolicyInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryGroupMembersRequest(betterproto.Message):
    """QueryGroupMembersRequest is the Query/GroupMembers request type."""

    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(1)
    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupMembersResponse(betterproto.Message):
    """
    QueryGroupMembersResponse is the Query/GroupMembersResponse response type.
    """

    # members are the members of the group with given group_id.
    members: List["GroupMember"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupsByAdminRequest(betterproto.Message):
    """QueryGroupsByAdminRequest is the Query/GroupsByAdmin request type."""

    # admin is the account address of a group's admin.
    admin: str = betterproto.string_field(1)
    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupsByAdminResponse(betterproto.Message):
    """
    QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response
    type.
    """

    # groups are the groups info with the provided admin.
    groups: List["GroupInfo"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByGroupRequest(betterproto.Message):
    """
    QueryGroupPoliciesByGroupRequest is the Query/GroupPoliciesByGroup request
    type.
    """

    # group_id is the unique ID of the group policy's group.
    group_id: int = betterproto.uint64_field(1)
    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByGroupResponse(betterproto.Message):
    """
    QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup
    response type.
    """

    # group_policies are the group policies info associated with the provided
    # group.
    group_policies: List["GroupPolicyInfo"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByAdminRequest(betterproto.Message):
    """
    QueryGroupPoliciesByAdminRequest is the Query/GroupPoliciesByAdmin request
    type.
    """

    # admin is the admin address of the group policy.
    admin: str = betterproto.string_field(1)
    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupPoliciesByAdminResponse(betterproto.Message):
    """
    QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin
    response type.
    """

    # group_policies are the group policies info with provided admin.
    group_policies: List["GroupPolicyInfo"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryProposalRequest(betterproto.Message):
    """QueryProposalRequest is the Query/Proposal request type."""

    # proposal_id is the unique ID of a proposal.
    proposal_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryProposalResponse(betterproto.Message):
    """QueryProposalResponse is the Query/Proposal response type."""

    # proposal is the proposal info.
    proposal: "Proposal" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryProposalsByGroupPolicyRequest(betterproto.Message):
    """
    QueryProposalsByGroupPolicyRequest is the Query/ProposalByGroupPolicy
    request type.
    """

    # address is the account address of the group policy related to proposals.
    address: str = betterproto.string_field(1)
    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryProposalsByGroupPolicyResponse(betterproto.Message):
    """
    QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy
    response type.
    """

    # proposals are the proposals with given group policy.
    proposals: List["Proposal"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryVoteByProposalVoterRequest(betterproto.Message):
    """
    QueryVoteByProposalVoterRequest is the Query/VoteByProposalVoter request
    type.
    """

    # proposal_id is the unique ID of a proposal.
    proposal_id: int = betterproto.uint64_field(1)
    # voter is a proposal voter account address.
    voter: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryVoteByProposalVoterResponse(betterproto.Message):
    """
    QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response
    type.
    """

    # vote is the vote with given proposal_id and voter.
    vote: "Vote" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryVotesByProposalRequest(betterproto.Message):
    """
    QueryVotesByProposalRequest is the Query/VotesByProposal request type.
    """

    # proposal_id is the unique ID of a proposal.
    proposal_id: int = betterproto.uint64_field(1)
    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryVotesByProposalResponse(betterproto.Message):
    """
    QueryVotesByProposalResponse is the Query/VotesByProposal response type.
    """

    # votes are the list of votes for given proposal_id.
    votes: List["Vote"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryVotesByVoterRequest(betterproto.Message):
    """QueryVotesByVoterRequest is the Query/VotesByVoter request type."""

    # voter is a proposal voter account address.
    voter: str = betterproto.string_field(1)
    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryVotesByVoterResponse(betterproto.Message):
    """QueryVotesByVoterResponse is the Query/VotesByVoter response type."""

    # votes are the list of votes by given voter.
    votes: List["Vote"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupsByMemberRequest(betterproto.Message):
    """QueryGroupsByMemberRequest is the Query/GroupsByMember request type."""

    # address is the group member address.
    address: str = betterproto.string_field(1)
    # pagination defines an optional pagination for the request.
    pagination: "__base_query_v1_beta1__.PageRequest" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupsByMemberResponse(betterproto.Message):
    """
    QueryGroupsByMemberResponse is the Query/GroupsByMember response type.
    """

    # groups are the groups info with the provided group member.
    groups: List["GroupInfo"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: "__base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryTallyResultRequest(betterproto.Message):
    """QueryTallyResultRequest is the Query/TallyResult request type."""

    # proposal_id is the unique id of a proposal.
    proposal_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryTallyResultResponse(betterproto.Message):
    """QueryTallyResultResponse is the Query/TallyResult response type."""

    # tally defines the requested tally.
    tally: "TallyResult" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class EventCreateGroup(betterproto.Message):
    """EventCreateGroup is an event emitted when a group is created."""

    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class EventUpdateGroup(betterproto.Message):
    """EventUpdateGroup is an event emitted when a group is updated."""

    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class EventCreateGroupPolicy(betterproto.Message):
    """
    EventCreateGroupPolicy is an event emitted when a group policy is created.
    """

    # address is the account address of the group policy.
    address: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EventUpdateGroupPolicy(betterproto.Message):
    """
    EventUpdateGroupPolicy is an event emitted when a group policy is updated.
    """

    # address is the account address of the group policy.
    address: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EventSubmitProposal(betterproto.Message):
    """EventSubmitProposal is an event emitted when a proposal is created."""

    # proposal_id is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class EventWithdrawProposal(betterproto.Message):
    """
    EventWithdrawProposal is an event emitted when a proposal is withdrawn.
    """

    # proposal_id is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class EventVote(betterproto.Message):
    """EventVote is an event emitted when a voter votes on a proposal."""

    # proposal_id is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class EventExec(betterproto.Message):
    """EventExec is an event emitted when a proposal is executed."""

    # proposal_id is the unique ID of the proposal.
    proposal_id: int = betterproto.uint64_field(1)
    # result is the proposal execution result.
    result: "ProposalExecutorResult" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class EventLeaveGroup(betterproto.Message):
    """
    EventLeaveGroup is an event emitted when group member leaves the group.
    """

    # group_id is the unique ID of the group.
    group_id: int = betterproto.uint64_field(1)
    # address is the account address of the group member.
    address: str = betterproto.string_field(2)


class MsgStub(betterproto.ServiceStub):
    async def create_group(
        self,
        *,
        admin: str = "",
        members: Optional[List["Member"]] = None,
        metadata: str = ""
    ) -> "MsgCreateGroupResponse":
        members = members or []

        request = MsgCreateGroup()
        request.admin = admin
        if members is not None:
            request.members = members
        request.metadata = metadata

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/CreateGroup", request, MsgCreateGroupResponse
        )

    async def update_group_members(
        self,
        *,
        admin: str = "",
        group_id: int = 0,
        member_updates: Optional[List["Member"]] = None
    ) -> "MsgUpdateGroupMembersResponse":
        member_updates = member_updates or []

        request = MsgUpdateGroupMembers()
        request.admin = admin
        request.group_id = group_id
        if member_updates is not None:
            request.member_updates = member_updates

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupMembers",
            request,
            MsgUpdateGroupMembersResponse,
        )

    async def update_group_admin(
        self, *, admin: str = "", group_id: int = 0, new_admin: str = ""
    ) -> "MsgUpdateGroupAdminResponse":

        request = MsgUpdateGroupAdmin()
        request.admin = admin
        request.group_id = group_id
        request.new_admin = new_admin

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupAdmin",
            request,
            MsgUpdateGroupAdminResponse,
        )

    async def update_group_metadata(
        self, *, admin: str = "", group_id: int = 0, metadata: str = ""
    ) -> "MsgUpdateGroupMetadataResponse":

        request = MsgUpdateGroupMetadata()
        request.admin = admin
        request.group_id = group_id
        request.metadata = metadata

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupMetadata",
            request,
            MsgUpdateGroupMetadataResponse,
        )

    async def create_group_policy(
        self,
        *,
        admin: str = "",
        group_id: int = 0,
        metadata: str = "",
        decision_policy: "betterproto_lib_google_protobuf.Any" = None
    ) -> "MsgCreateGroupPolicyResponse":

        request = MsgCreateGroupPolicy()
        request.admin = admin
        request.group_id = group_id
        request.metadata = metadata
        if decision_policy is not None:
            request.decision_policy = decision_policy

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/CreateGroupPolicy",
            request,
            MsgCreateGroupPolicyResponse,
        )

    async def create_group_with_policy(
        self,
        *,
        admin: str = "",
        members: Optional[List["Member"]] = None,
        group_metadata: str = "",
        group_policy_metadata: str = "",
        group_policy_as_admin: bool = False,
        decision_policy: "betterproto_lib_google_protobuf.Any" = None
    ) -> "MsgCreateGroupWithPolicyResponse":
        members = members or []

        request = MsgCreateGroupWithPolicy()
        request.admin = admin
        if members is not None:
            request.members = members
        request.group_metadata = group_metadata
        request.group_policy_metadata = group_policy_metadata
        request.group_policy_as_admin = group_policy_as_admin
        if decision_policy is not None:
            request.decision_policy = decision_policy

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/CreateGroupWithPolicy",
            request,
            MsgCreateGroupWithPolicyResponse,
        )

    async def update_group_policy_admin(
        self, *, admin: str = "", address: str = "", new_admin: str = ""
    ) -> "MsgUpdateGroupPolicyAdminResponse":

        request = MsgUpdateGroupPolicyAdmin()
        request.admin = admin
        request.address = address
        request.new_admin = new_admin

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupPolicyAdmin",
            request,
            MsgUpdateGroupPolicyAdminResponse,
        )

    async def update_group_policy_decision_policy(
        self,
        *,
        admin: str = "",
        address: str = "",
        decision_policy: "betterproto_lib_google_protobuf.Any" = None
    ) -> "MsgUpdateGroupPolicyDecisionPolicyResponse":

        request = MsgUpdateGroupPolicyDecisionPolicy()
        request.admin = admin
        request.address = address
        if decision_policy is not None:
            request.decision_policy = decision_policy

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupPolicyDecisionPolicy",
            request,
            MsgUpdateGroupPolicyDecisionPolicyResponse,
        )

    async def update_group_policy_metadata(
        self, *, admin: str = "", address: str = "", metadata: str = ""
    ) -> "MsgUpdateGroupPolicyMetadataResponse":

        request = MsgUpdateGroupPolicyMetadata()
        request.admin = admin
        request.address = address
        request.metadata = metadata

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/UpdateGroupPolicyMetadata",
            request,
            MsgUpdateGroupPolicyMetadataResponse,
        )

    async def submit_proposal(
        self,
        *,
        address: str = "",
        proposers: Optional[List[str]] = None,
        metadata: str = "",
        messages: Optional[List["betterproto_lib_google_protobuf.Any"]] = None,
        exec: "Exec" = 0
    ) -> "MsgSubmitProposalResponse":
        proposers = proposers or []
        messages = messages or []

        request = MsgSubmitProposal()
        request.address = address
        request.proposers = proposers
        request.metadata = metadata
        if messages is not None:
            request.messages = messages
        request.exec = exec

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/SubmitProposal", request, MsgSubmitProposalResponse
        )

    async def withdraw_proposal(
        self, *, proposal_id: int = 0, address: str = ""
    ) -> "MsgWithdrawProposalResponse":

        request = MsgWithdrawProposal()
        request.proposal_id = proposal_id
        request.address = address

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/WithdrawProposal",
            request,
            MsgWithdrawProposalResponse,
        )

    async def vote(
        self,
        *,
        proposal_id: int = 0,
        voter: str = "",
        option: "VoteOption" = 0,
        metadata: str = "",
        exec: "Exec" = 0
    ) -> "MsgVoteResponse":

        request = MsgVote()
        request.proposal_id = proposal_id
        request.voter = voter
        request.option = option
        request.metadata = metadata
        request.exec = exec

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/Vote", request, MsgVoteResponse
        )

    async def exec(
        self, *, proposal_id: int = 0, signer: str = ""
    ) -> "MsgExecResponse":

        request = MsgExec()
        request.proposal_id = proposal_id
        request.signer = signer

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/Exec", request, MsgExecResponse
        )

    async def leave_group(
        self, *, address: str = "", group_id: int = 0
    ) -> "MsgLeaveGroupResponse":

        request = MsgLeaveGroup()
        request.address = address
        request.group_id = group_id

        return await self._unary_unary(
            "/cosmos.group.v1.Msg/LeaveGroup", request, MsgLeaveGroupResponse
        )


class QueryStub(betterproto.ServiceStub):
    async def group_info(self, *, group_id: int = 0) -> "QueryGroupInfoResponse":

        request = QueryGroupInfoRequest()
        request.group_id = group_id

        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupInfo", request, QueryGroupInfoResponse
        )

    async def group_policy_info(
        self, *, address: str = ""
    ) -> "QueryGroupPolicyInfoResponse":

        request = QueryGroupPolicyInfoRequest()
        request.address = address

        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPolicyInfo",
            request,
            QueryGroupPolicyInfoResponse,
        )

    async def group_members(
        self,
        *,
        group_id: int = 0,
        pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryGroupMembersResponse":

        request = QueryGroupMembersRequest()
        request.group_id = group_id
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupMembers", request, QueryGroupMembersResponse
        )

    async def groups_by_admin(
        self,
        *,
        admin: str = "",
        pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryGroupsByAdminResponse":

        request = QueryGroupsByAdminRequest()
        request.admin = admin
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupsByAdmin", request, QueryGroupsByAdminResponse
        )

    async def group_policies_by_group(
        self,
        *,
        group_id: int = 0,
        pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryGroupPoliciesByGroupResponse":

        request = QueryGroupPoliciesByGroupRequest()
        request.group_id = group_id
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPoliciesByGroup",
            request,
            QueryGroupPoliciesByGroupResponse,
        )

    async def group_policies_by_admin(
        self,
        *,
        admin: str = "",
        pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryGroupPoliciesByAdminResponse":

        request = QueryGroupPoliciesByAdminRequest()
        request.admin = admin
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupPoliciesByAdmin",
            request,
            QueryGroupPoliciesByAdminResponse,
        )

    async def proposal(self, *, proposal_id: int = 0) -> "QueryProposalResponse":

        request = QueryProposalRequest()
        request.proposal_id = proposal_id

        return await self._unary_unary(
            "/cosmos.group.v1.Query/Proposal", request, QueryProposalResponse
        )

    async def proposals_by_group_policy(
        self,
        *,
        address: str = "",
        pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryProposalsByGroupPolicyResponse":

        request = QueryProposalsByGroupPolicyRequest()
        request.address = address
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.group.v1.Query/ProposalsByGroupPolicy",
            request,
            QueryProposalsByGroupPolicyResponse,
        )

    async def vote_by_proposal_voter(
        self, *, proposal_id: int = 0, voter: str = ""
    ) -> "QueryVoteByProposalVoterResponse":

        request = QueryVoteByProposalVoterRequest()
        request.proposal_id = proposal_id
        request.voter = voter

        return await self._unary_unary(
            "/cosmos.group.v1.Query/VoteByProposalVoter",
            request,
            QueryVoteByProposalVoterResponse,
        )

    async def votes_by_proposal(
        self,
        *,
        proposal_id: int = 0,
        pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryVotesByProposalResponse":

        request = QueryVotesByProposalRequest()
        request.proposal_id = proposal_id
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.group.v1.Query/VotesByProposal",
            request,
            QueryVotesByProposalResponse,
        )

    async def votes_by_voter(
        self,
        *,
        voter: str = "",
        pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryVotesByVoterResponse":

        request = QueryVotesByVoterRequest()
        request.voter = voter
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.group.v1.Query/VotesByVoter", request, QueryVotesByVoterResponse
        )

    async def groups_by_member(
        self,
        *,
        address: str = "",
        pagination: "__base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryGroupsByMemberResponse":

        request = QueryGroupsByMemberRequest()
        request.address = address
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.group.v1.Query/GroupsByMember",
            request,
            QueryGroupsByMemberResponse,
        )

    async def tally_result(self, *, proposal_id: int = 0) -> "QueryTallyResultResponse":

        request = QueryTallyResultRequest()
        request.proposal_id = proposal_id

        return await self._unary_unary(
            "/cosmos.group.v1.Query/TallyResult", request, QueryTallyResultResponse
        )


class MsgBase(ServiceBase):
    async def create_group(
        self, admin: str, members: Optional[List["Member"]], metadata: str
    ) -> "MsgCreateGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_members(
        self, admin: str, group_id: int, member_updates: Optional[List["Member"]]
    ) -> "MsgUpdateGroupMembersResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_admin(
        self, admin: str, group_id: int, new_admin: str
    ) -> "MsgUpdateGroupAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_metadata(
        self, admin: str, group_id: int, metadata: str
    ) -> "MsgUpdateGroupMetadataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_group_policy(
        self,
        admin: str,
        group_id: int,
        metadata: str,
        decision_policy: "betterproto_lib_google_protobuf.Any",
    ) -> "MsgCreateGroupPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_group_with_policy(
        self,
        admin: str,
        members: Optional[List["Member"]],
        group_metadata: str,
        group_policy_metadata: str,
        group_policy_as_admin: bool,
        decision_policy: "betterproto_lib_google_protobuf.Any",
    ) -> "MsgCreateGroupWithPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_policy_admin(
        self, admin: str, address: str, new_admin: str
    ) -> "MsgUpdateGroupPolicyAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_policy_decision_policy(
        self,
        admin: str,
        address: str,
        decision_policy: "betterproto_lib_google_protobuf.Any",
    ) -> "MsgUpdateGroupPolicyDecisionPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_policy_metadata(
        self, admin: str, address: str, metadata: str
    ) -> "MsgUpdateGroupPolicyMetadataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def submit_proposal(
        self,
        address: str,
        proposers: Optional[List[str]],
        metadata: str,
        messages: Optional[List["betterproto_lib_google_protobuf.Any"]],
        exec: "Exec",
    ) -> "MsgSubmitProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def withdraw_proposal(
        self, proposal_id: int, address: str
    ) -> "MsgWithdrawProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def vote(
        self,
        proposal_id: int,
        voter: str,
        option: "VoteOption",
        metadata: str,
        exec: "Exec",
    ) -> "MsgVoteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exec(self, proposal_id: int, signer: str) -> "MsgExecResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def leave_group(self, address: str, group_id: int) -> "MsgLeaveGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_group(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "members": request.members,
            "metadata": request.metadata,
        }

        response = await self.create_group(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_group_members(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "group_id": request.group_id,
            "member_updates": request.member_updates,
        }

        response = await self.update_group_members(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_group_admin(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "group_id": request.group_id,
            "new_admin": request.new_admin,
        }

        response = await self.update_group_admin(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_group_metadata(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "group_id": request.group_id,
            "metadata": request.metadata,
        }

        response = await self.update_group_metadata(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_create_group_policy(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "group_id": request.group_id,
            "metadata": request.metadata,
            "decision_policy": request.decision_policy,
        }

        response = await self.create_group_policy(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_create_group_with_policy(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "members": request.members,
            "group_metadata": request.group_metadata,
            "group_policy_metadata": request.group_policy_metadata,
            "group_policy_as_admin": request.group_policy_as_admin,
            "decision_policy": request.decision_policy,
        }

        response = await self.create_group_with_policy(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_group_policy_admin(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "address": request.address,
            "new_admin": request.new_admin,
        }

        response = await self.update_group_policy_admin(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_group_policy_decision_policy(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "address": request.address,
            "decision_policy": request.decision_policy,
        }

        response = await self.update_group_policy_decision_policy(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_group_policy_metadata(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "address": request.address,
            "metadata": request.metadata,
        }

        response = await self.update_group_policy_metadata(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_submit_proposal(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "address": request.address,
            "proposers": request.proposers,
            "metadata": request.metadata,
            "messages": request.messages,
            "exec": request.exec,
        }

        response = await self.submit_proposal(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_withdraw_proposal(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "proposal_id": request.proposal_id,
            "address": request.address,
        }

        response = await self.withdraw_proposal(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_vote(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "proposal_id": request.proposal_id,
            "voter": request.voter,
            "option": request.option,
            "metadata": request.metadata,
            "exec": request.exec,
        }

        response = await self.vote(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_exec(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "proposal_id": request.proposal_id,
            "signer": request.signer,
        }

        response = await self.exec(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_leave_group(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "address": request.address,
            "group_id": request.group_id,
        }

        response = await self.leave_group(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.group.v1.Msg/CreateGroup": grpclib.const.Handler(
                self.__rpc_create_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGroup,
                MsgCreateGroupResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupMembers": grpclib.const.Handler(
                self.__rpc_update_group_members,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupMembers,
                MsgUpdateGroupMembersResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupAdmin": grpclib.const.Handler(
                self.__rpc_update_group_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupAdmin,
                MsgUpdateGroupAdminResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupMetadata": grpclib.const.Handler(
                self.__rpc_update_group_metadata,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupMetadata,
                MsgUpdateGroupMetadataResponse,
            ),
            "/cosmos.group.v1.Msg/CreateGroupPolicy": grpclib.const.Handler(
                self.__rpc_create_group_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGroupPolicy,
                MsgCreateGroupPolicyResponse,
            ),
            "/cosmos.group.v1.Msg/CreateGroupWithPolicy": grpclib.const.Handler(
                self.__rpc_create_group_with_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGroupWithPolicy,
                MsgCreateGroupWithPolicyResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupPolicyAdmin": grpclib.const.Handler(
                self.__rpc_update_group_policy_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupPolicyAdmin,
                MsgUpdateGroupPolicyAdminResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupPolicyDecisionPolicy": grpclib.const.Handler(
                self.__rpc_update_group_policy_decision_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupPolicyDecisionPolicy,
                MsgUpdateGroupPolicyDecisionPolicyResponse,
            ),
            "/cosmos.group.v1.Msg/UpdateGroupPolicyMetadata": grpclib.const.Handler(
                self.__rpc_update_group_policy_metadata,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupPolicyMetadata,
                MsgUpdateGroupPolicyMetadataResponse,
            ),
            "/cosmos.group.v1.Msg/SubmitProposal": grpclib.const.Handler(
                self.__rpc_submit_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSubmitProposal,
                MsgSubmitProposalResponse,
            ),
            "/cosmos.group.v1.Msg/WithdrawProposal": grpclib.const.Handler(
                self.__rpc_withdraw_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgWithdrawProposal,
                MsgWithdrawProposalResponse,
            ),
            "/cosmos.group.v1.Msg/Vote": grpclib.const.Handler(
                self.__rpc_vote,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgVote,
                MsgVoteResponse,
            ),
            "/cosmos.group.v1.Msg/Exec": grpclib.const.Handler(
                self.__rpc_exec,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExec,
                MsgExecResponse,
            ),
            "/cosmos.group.v1.Msg/LeaveGroup": grpclib.const.Handler(
                self.__rpc_leave_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgLeaveGroup,
                MsgLeaveGroupResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def group_info(self, group_id: int) -> "QueryGroupInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policy_info(self, address: str) -> "QueryGroupPolicyInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_members(
        self, group_id: int, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryGroupMembersResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def groups_by_admin(
        self, admin: str, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryGroupsByAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policies_by_group(
        self, group_id: int, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryGroupPoliciesByGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def group_policies_by_admin(
        self, admin: str, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryGroupPoliciesByAdminResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def proposal(self, proposal_id: int) -> "QueryProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def proposals_by_group_policy(
        self, address: str, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryProposalsByGroupPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def vote_by_proposal_voter(
        self, proposal_id: int, voter: str
    ) -> "QueryVoteByProposalVoterResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def votes_by_proposal(
        self, proposal_id: int, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryVotesByProposalResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def votes_by_voter(
        self, voter: str, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryVotesByVoterResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def groups_by_member(
        self, address: str, pagination: "__base_query_v1_beta1__.PageRequest"
    ) -> "QueryGroupsByMemberResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tally_result(self, proposal_id: int) -> "QueryTallyResultResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_group_info(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "group_id": request.group_id,
        }

        response = await self.group_info(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_group_policy_info(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "address": request.address,
        }

        response = await self.group_policy_info(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_group_members(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "group_id": request.group_id,
            "pagination": request.pagination,
        }

        response = await self.group_members(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_groups_by_admin(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "pagination": request.pagination,
        }

        response = await self.groups_by_admin(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_group_policies_by_group(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "group_id": request.group_id,
            "pagination": request.pagination,
        }

        response = await self.group_policies_by_group(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_group_policies_by_admin(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "admin": request.admin,
            "pagination": request.pagination,
        }

        response = await self.group_policies_by_admin(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_proposal(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "proposal_id": request.proposal_id,
        }

        response = await self.proposal(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_proposals_by_group_policy(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "address": request.address,
            "pagination": request.pagination,
        }

        response = await self.proposals_by_group_policy(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_vote_by_proposal_voter(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "proposal_id": request.proposal_id,
            "voter": request.voter,
        }

        response = await self.vote_by_proposal_voter(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_votes_by_proposal(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "proposal_id": request.proposal_id,
            "pagination": request.pagination,
        }

        response = await self.votes_by_proposal(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_votes_by_voter(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "voter": request.voter,
            "pagination": request.pagination,
        }

        response = await self.votes_by_voter(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_groups_by_member(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "address": request.address,
            "pagination": request.pagination,
        }

        response = await self.groups_by_member(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_tally_result(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "proposal_id": request.proposal_id,
        }

        response = await self.tally_result(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/cosmos.group.v1.Query/GroupInfo": grpclib.const.Handler(
                self.__rpc_group_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupInfoRequest,
                QueryGroupInfoResponse,
            ),
            "/cosmos.group.v1.Query/GroupPolicyInfo": grpclib.const.Handler(
                self.__rpc_group_policy_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPolicyInfoRequest,
                QueryGroupPolicyInfoResponse,
            ),
            "/cosmos.group.v1.Query/GroupMembers": grpclib.const.Handler(
                self.__rpc_group_members,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupMembersRequest,
                QueryGroupMembersResponse,
            ),
            "/cosmos.group.v1.Query/GroupsByAdmin": grpclib.const.Handler(
                self.__rpc_groups_by_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsByAdminRequest,
                QueryGroupsByAdminResponse,
            ),
            "/cosmos.group.v1.Query/GroupPoliciesByGroup": grpclib.const.Handler(
                self.__rpc_group_policies_by_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPoliciesByGroupRequest,
                QueryGroupPoliciesByGroupResponse,
            ),
            "/cosmos.group.v1.Query/GroupPoliciesByAdmin": grpclib.const.Handler(
                self.__rpc_group_policies_by_admin,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupPoliciesByAdminRequest,
                QueryGroupPoliciesByAdminResponse,
            ),
            "/cosmos.group.v1.Query/Proposal": grpclib.const.Handler(
                self.__rpc_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryProposalRequest,
                QueryProposalResponse,
            ),
            "/cosmos.group.v1.Query/ProposalsByGroupPolicy": grpclib.const.Handler(
                self.__rpc_proposals_by_group_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryProposalsByGroupPolicyRequest,
                QueryProposalsByGroupPolicyResponse,
            ),
            "/cosmos.group.v1.Query/VoteByProposalVoter": grpclib.const.Handler(
                self.__rpc_vote_by_proposal_voter,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVoteByProposalVoterRequest,
                QueryVoteByProposalVoterResponse,
            ),
            "/cosmos.group.v1.Query/VotesByProposal": grpclib.const.Handler(
                self.__rpc_votes_by_proposal,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVotesByProposalRequest,
                QueryVotesByProposalResponse,
            ),
            "/cosmos.group.v1.Query/VotesByVoter": grpclib.const.Handler(
                self.__rpc_votes_by_voter,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVotesByVoterRequest,
                QueryVotesByVoterResponse,
            ),
            "/cosmos.group.v1.Query/GroupsByMember": grpclib.const.Handler(
                self.__rpc_groups_by_member,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsByMemberRequest,
                QueryGroupsByMemberResponse,
            ),
            "/cosmos.group.v1.Query/TallyResult": grpclib.const.Handler(
                self.__rpc_tally_result,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTallyResultRequest,
                QueryTallyResultResponse,
            ),
        }


from ...base.query import v1beta1 as __base_query_v1_beta1__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
