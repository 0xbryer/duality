# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: dex/adjancey_matrix.proto, dex/edge_row.proto, dex/fee_list.proto, dex/genesis.proto, dex/limit_order_pool.proto, dex/limit_order_pool_fill_map.proto, dex/limit_order_pool_reserve_map.proto, dex/limit_order_pool_total_shares_map.proto, dex/limit_order_pool_user_share_map.proto, dex/limit_order_pool_user_shares_withdrawn.proto, dex/pair_map.proto, dex/params.proto, dex/query.proto, dex/reserve_0_and_shares_type.proto, dex/shares.proto, dex/tick_data_type.proto, dex/tick_map.proto, dex/token_map.proto, dex/token_pair_type.proto, dex/tokens.proto, dex/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class LimitOrderPoolUserSharesWithdrawn(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    token: str = betterproto.string_field(2)
    tick_index: int = betterproto.int64_field(3)
    count: int = betterproto.uint64_field(4)
    address: str = betterproto.string_field(5)
    shares_withdrawn: str = betterproto.string_field(6)


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    pass


@dataclass(eq=False, repr=False)
class LimitOrderPool(betterproto.Message):
    count: int = betterproto.uint64_field(1)
    current_limit_order_key: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class TokenMap(betterproto.Message):
    address: str = betterproto.string_field(1)
    index: int = betterproto.int64_field(2)


@dataclass(eq=False, repr=False)
class FeeList(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    fee: int = betterproto.int64_field(2)


@dataclass(eq=False, repr=False)
class Tokens(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    address: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgDeposit(betterproto.Message):
    creator: str = betterproto.string_field(1)
    receiver: str = betterproto.string_field(2)
    token_a: str = betterproto.string_field(3)
    token_b: str = betterproto.string_field(4)
    amounts_a: List[str] = betterproto.string_field(5)
    amounts_b: List[str] = betterproto.string_field(6)
    tick_indexes: List[int] = betterproto.int64_field(7)
    fee_indexes: List[int] = betterproto.uint64_field(8)


@dataclass(eq=False, repr=False)
class MsgDepositResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgWithdrawl(betterproto.Message):
    creator: str = betterproto.string_field(1)
    receiver: str = betterproto.string_field(2)
    token_a: str = betterproto.string_field(3)
    token_b: str = betterproto.string_field(4)
    shares_to_remove: List[str] = betterproto.string_field(5)
    tick_indexes: List[int] = betterproto.int64_field(6)
    fee_indexes: List[int] = betterproto.uint64_field(7)


@dataclass(eq=False, repr=False)
class MsgWithdrawlResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgSwap(betterproto.Message):
    creator: str = betterproto.string_field(1)
    receiver: str = betterproto.string_field(2)
    token_a: str = betterproto.string_field(3)
    token_b: str = betterproto.string_field(4)
    amount_in: str = betterproto.string_field(5)
    token_in: str = betterproto.string_field(6)
    min_out: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class MsgSwapResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgPlaceLimitOrder(betterproto.Message):
    creator: str = betterproto.string_field(1)
    receiver: str = betterproto.string_field(2)
    token_a: str = betterproto.string_field(3)
    token_b: str = betterproto.string_field(4)
    tick_index: int = betterproto.int64_field(5)
    token_in: str = betterproto.string_field(6)
    amount_in: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class MsgPlaceLimitOrderResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgWithdrawFilledLimitOrder(betterproto.Message):
    creator: str = betterproto.string_field(1)
    receiver: str = betterproto.string_field(2)
    token_a: str = betterproto.string_field(3)
    token_b: str = betterproto.string_field(4)
    tick_index: int = betterproto.int64_field(5)
    key_token: str = betterproto.string_field(6)
    key: int = betterproto.uint64_field(7)


@dataclass(eq=False, repr=False)
class MsgWithdrawFilledLimitOrderResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgCancelLimitOrder(betterproto.Message):
    creator: str = betterproto.string_field(1)
    receiver: str = betterproto.string_field(2)
    token_a: str = betterproto.string_field(3)
    token_b: str = betterproto.string_field(4)
    tick_index: int = betterproto.int64_field(5)
    key_token: str = betterproto.string_field(6)
    key: int = betterproto.uint64_field(7)
    shares_out: str = betterproto.string_field(8)


@dataclass(eq=False, repr=False)
class MsgCancelLimitOrderResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class TokenPairType(betterproto.Message):
    current_tick0_to1: int = betterproto.int64_field(1)
    current_tick1_to0: int = betterproto.int64_field(2)


@dataclass(eq=False, repr=False)
class Reserve0AndSharesType(betterproto.Message):
    reserve0: str = betterproto.string_field(1)
    total_shares: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class TickDataType(betterproto.Message):
    reserve0_and_shares: List["Reserve0AndSharesType"] = betterproto.message_field(1)
    reserve1: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class TickMap(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    tick_index: int = betterproto.int64_field(2)
    tick_data: "TickDataType" = betterproto.message_field(3)
    limit_order_pool0_to1: "LimitOrderPool" = betterproto.message_field(4)
    limit_order_pool1_to0: "LimitOrderPool" = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class PairMap(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    token_pair: "TokenPairType" = betterproto.message_field(2)
    total_tick_count: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class Shares(betterproto.Message):
    address: str = betterproto.string_field(1)
    pair_id: str = betterproto.string_field(2)
    tick_index: int = betterproto.int64_field(3)
    fee_index: int = betterproto.uint64_field(4)
    shares_owned: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class EdgeRow(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    edge: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class AdjanceyMatrix(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    edge_row: "EdgeRow" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class LimitOrderPoolUserShareMap(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    token: str = betterproto.string_field(2)
    tick_index: int = betterproto.int64_field(3)
    count: int = betterproto.uint64_field(4)
    address: str = betterproto.string_field(5)
    shares_owned: str = betterproto.string_field(6)


@dataclass(eq=False, repr=False)
class LimitOrderPoolTotalSharesMap(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    token: str = betterproto.string_field(2)
    tick_index: int = betterproto.int64_field(3)
    count: int = betterproto.uint64_field(4)
    total_shares: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class LimitOrderPoolReserveMap(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    token: str = betterproto.string_field(2)
    tick_index: int = betterproto.int64_field(3)
    count: int = betterproto.uint64_field(4)
    reserves: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class LimitOrderPoolFillMap(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    token: str = betterproto.string_field(2)
    tick_index: int = betterproto.int64_field(3)
    count: int = betterproto.uint64_field(4)
    filled_reserves: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the dex module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    tick_map_list: List["TickMap"] = betterproto.message_field(2)
    pair_map_list: List["PairMap"] = betterproto.message_field(3)
    tokens_list: List["Tokens"] = betterproto.message_field(4)
    tokens_count: int = betterproto.uint64_field(5)
    token_map_list: List["TokenMap"] = betterproto.message_field(6)
    shares_list: List["Shares"] = betterproto.message_field(7)
    fee_list_list: List["FeeList"] = betterproto.message_field(8)
    fee_list_count: int = betterproto.uint64_field(9)
    edge_row_list: List["EdgeRow"] = betterproto.message_field(10)
    edge_row_count: int = betterproto.uint64_field(11)
    adjancey_matrix_list: List["AdjanceyMatrix"] = betterproto.message_field(12)
    adjancey_matrix_count: int = betterproto.uint64_field(13)
    limit_order_pool_user_share_map_list: List[
        "LimitOrderPoolUserShareMap"
    ] = betterproto.message_field(14)
    limit_order_pool_user_shares_withdrawn_list: List[
        "LimitOrderPoolUserSharesWithdrawn"
    ] = betterproto.message_field(15)
    limit_order_pool_total_shares_map_list: List[
        "LimitOrderPoolTotalSharesMap"
    ] = betterproto.message_field(16)
    limit_order_pool_reserve_map_list: List[
        "LimitOrderPoolReserveMap"
    ] = betterproto.message_field(17)
    limit_order_pool_fill_map_list: List[
        "LimitOrderPoolFillMap"
    ] = betterproto.message_field(18)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    # params holds all the parameters of this module.
    params: "Params" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryGetTickMapRequest(betterproto.Message):
    tick_index: int = betterproto.int64_field(1)
    pair_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryGetTickMapResponse(betterproto.Message):
    tick_map: "TickMap" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllTickMapRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllTickMapResponse(betterproto.Message):
    tick_map: List["TickMap"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetPairMapRequest(betterproto.Message):
    pair_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryGetPairMapResponse(betterproto.Message):
    pair_map: "PairMap" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllPairMapRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllPairMapResponse(betterproto.Message):
    pair_map: List["PairMap"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetTokensRequest(betterproto.Message):
    id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryGetTokensResponse(betterproto.Message):
    tokens: "Tokens" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllTokensRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllTokensResponse(betterproto.Message):
    tokens: List["Tokens"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetTokenMapRequest(betterproto.Message):
    address: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryGetTokenMapResponse(betterproto.Message):
    token_map: "TokenMap" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllTokenMapRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllTokenMapResponse(betterproto.Message):
    token_map: List["TokenMap"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetSharesRequest(betterproto.Message):
    address: str = betterproto.string_field(1)
    pair_id: str = betterproto.string_field(2)
    tick_index: int = betterproto.int64_field(3)
    fee: int = betterproto.uint64_field(4)


@dataclass(eq=False, repr=False)
class QueryGetSharesResponse(betterproto.Message):
    shares: "Shares" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllSharesRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllSharesResponse(betterproto.Message):
    shares: List["Shares"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetFeeListRequest(betterproto.Message):
    id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryGetFeeListResponse(betterproto.Message):
    fee_list: "FeeList" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllFeeListRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllFeeListResponse(betterproto.Message):
    fee_list: List["FeeList"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetEdgeRowRequest(betterproto.Message):
    id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryGetEdgeRowResponse(betterproto.Message):
    edge_row: "EdgeRow" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllEdgeRowRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllEdgeRowResponse(betterproto.Message):
    edge_row: List["EdgeRow"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetAdjanceyMatrixRequest(betterproto.Message):
    id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryGetAdjanceyMatrixResponse(betterproto.Message):
    adjancey_matrix: "AdjanceyMatrix" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllAdjanceyMatrixRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllAdjanceyMatrixResponse(betterproto.Message):
    adjancey_matrix: List["AdjanceyMatrix"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolUserShareMapRequest(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    tick_index: int = betterproto.int64_field(2)
    token: str = betterproto.string_field(3)
    count: int = betterproto.uint64_field(4)
    address: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolUserShareMapResponse(betterproto.Message):
    limit_order_pool_user_share_map: "LimitOrderPoolUserShareMap" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolUserShareMapRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolUserShareMapResponse(betterproto.Message):
    limit_order_pool_user_share_map: List[
        "LimitOrderPoolUserShareMap"
    ] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolUserSharesWithdrawnRequest(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    tick_index: int = betterproto.int64_field(2)
    token: str = betterproto.string_field(3)
    count: int = betterproto.uint64_field(4)
    address: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolUserSharesWithdrawnResponse(betterproto.Message):
    limit_order_pool_user_shares_withdrawn: "LimitOrderPoolUserSharesWithdrawn" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolUserSharesWithdrawnRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolUserSharesWithdrawnResponse(betterproto.Message):
    limit_order_pool_user_shares_withdrawn: List[
        "LimitOrderPoolUserSharesWithdrawn"
    ] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolTotalSharesMapRequest(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    tick_index: int = betterproto.int64_field(2)
    token: str = betterproto.string_field(3)
    count: int = betterproto.uint64_field(4)


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolTotalSharesMapResponse(betterproto.Message):
    limit_order_pool_total_shares_map: "LimitOrderPoolTotalSharesMap" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolTotalSharesMapRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolTotalSharesMapResponse(betterproto.Message):
    limit_order_pool_total_shares_map: List[
        "LimitOrderPoolTotalSharesMap"
    ] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolReserveMapRequest(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    tick_index: int = betterproto.int64_field(2)
    token: str = betterproto.string_field(3)
    count: int = betterproto.uint64_field(4)


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolReserveMapResponse(betterproto.Message):
    limit_order_pool_reserve_map: "LimitOrderPoolReserveMap" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolReserveMapRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolReserveMapResponse(betterproto.Message):
    limit_order_pool_reserve_map: List[
        "LimitOrderPoolReserveMap"
    ] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolFillMapRequest(betterproto.Message):
    pair_id: str = betterproto.string_field(1)
    tick_index: int = betterproto.int64_field(2)
    token: str = betterproto.string_field(3)
    count: int = betterproto.uint64_field(4)


@dataclass(eq=False, repr=False)
class QueryGetLimitOrderPoolFillMapResponse(betterproto.Message):
    limit_order_pool_fill_map: "LimitOrderPoolFillMap" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolFillMapRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QueryAllLimitOrderPoolFillMapResponse(betterproto.Message):
    limit_order_pool_fill_map: List[
        "LimitOrderPoolFillMap"
    ] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


class MsgStub(betterproto.ServiceStub):
    async def deposit(
        self,
        *,
        creator: str = "",
        receiver: str = "",
        token_a: str = "",
        token_b: str = "",
        amounts_a: Optional[List[str]] = None,
        amounts_b: Optional[List[str]] = None,
        tick_indexes: Optional[List[int]] = None,
        fee_indexes: Optional[List[int]] = None
    ) -> "MsgDepositResponse":
        amounts_a = amounts_a or []
        amounts_b = amounts_b or []
        tick_indexes = tick_indexes or []
        fee_indexes = fee_indexes or []

        request = MsgDeposit()
        request.creator = creator
        request.receiver = receiver
        request.token_a = token_a
        request.token_b = token_b
        request.amounts_a = amounts_a
        request.amounts_b = amounts_b
        request.tick_indexes = tick_indexes
        request.fee_indexes = fee_indexes

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Msg/Deposit", request, MsgDepositResponse
        )

    async def withdrawl(
        self,
        *,
        creator: str = "",
        receiver: str = "",
        token_a: str = "",
        token_b: str = "",
        shares_to_remove: Optional[List[str]] = None,
        tick_indexes: Optional[List[int]] = None,
        fee_indexes: Optional[List[int]] = None
    ) -> "MsgWithdrawlResponse":
        shares_to_remove = shares_to_remove or []
        tick_indexes = tick_indexes or []
        fee_indexes = fee_indexes or []

        request = MsgWithdrawl()
        request.creator = creator
        request.receiver = receiver
        request.token_a = token_a
        request.token_b = token_b
        request.shares_to_remove = shares_to_remove
        request.tick_indexes = tick_indexes
        request.fee_indexes = fee_indexes

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Msg/Withdrawl", request, MsgWithdrawlResponse
        )

    async def swap(
        self,
        *,
        creator: str = "",
        receiver: str = "",
        token_a: str = "",
        token_b: str = "",
        amount_in: str = "",
        token_in: str = "",
        min_out: str = ""
    ) -> "MsgSwapResponse":

        request = MsgSwap()
        request.creator = creator
        request.receiver = receiver
        request.token_a = token_a
        request.token_b = token_b
        request.amount_in = amount_in
        request.token_in = token_in
        request.min_out = min_out

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Msg/Swap", request, MsgSwapResponse
        )

    async def place_limit_order(
        self,
        *,
        creator: str = "",
        receiver: str = "",
        token_a: str = "",
        token_b: str = "",
        tick_index: int = 0,
        token_in: str = "",
        amount_in: str = ""
    ) -> "MsgPlaceLimitOrderResponse":

        request = MsgPlaceLimitOrder()
        request.creator = creator
        request.receiver = receiver
        request.token_a = token_a
        request.token_b = token_b
        request.tick_index = tick_index
        request.token_in = token_in
        request.amount_in = amount_in

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Msg/PlaceLimitOrder",
            request,
            MsgPlaceLimitOrderResponse,
        )

    async def withdraw_filled_limit_order(
        self,
        *,
        creator: str = "",
        receiver: str = "",
        token_a: str = "",
        token_b: str = "",
        tick_index: int = 0,
        key_token: str = "",
        key: int = 0
    ) -> "MsgWithdrawFilledLimitOrderResponse":

        request = MsgWithdrawFilledLimitOrder()
        request.creator = creator
        request.receiver = receiver
        request.token_a = token_a
        request.token_b = token_b
        request.tick_index = tick_index
        request.key_token = key_token
        request.key = key

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Msg/WithdrawFilledLimitOrder",
            request,
            MsgWithdrawFilledLimitOrderResponse,
        )

    async def cancel_limit_order(
        self,
        *,
        creator: str = "",
        receiver: str = "",
        token_a: str = "",
        token_b: str = "",
        tick_index: int = 0,
        key_token: str = "",
        key: int = 0,
        shares_out: str = ""
    ) -> "MsgCancelLimitOrderResponse":

        request = MsgCancelLimitOrder()
        request.creator = creator
        request.receiver = receiver
        request.token_a = token_a
        request.token_b = token_b
        request.tick_index = tick_index
        request.key_token = key_token
        request.key = key
        request.shares_out = shares_out

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Msg/CancelLimitOrder",
            request,
            MsgCancelLimitOrderResponse,
        )


class QueryStub(betterproto.ServiceStub):
    async def params(self) -> "QueryParamsResponse":

        request = QueryParamsRequest()

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/Params", request, QueryParamsResponse
        )

    async def tick_map(
        self, *, tick_index: int = 0, pair_id: str = ""
    ) -> "QueryGetTickMapResponse":

        request = QueryGetTickMapRequest()
        request.tick_index = tick_index
        request.pair_id = pair_id

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/TickMap",
            request,
            QueryGetTickMapResponse,
        )

    async def tick_map_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllTickMapResponse":

        request = QueryAllTickMapRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/TickMapAll",
            request,
            QueryAllTickMapResponse,
        )

    async def pair_map(self, *, pair_id: str = "") -> "QueryGetPairMapResponse":

        request = QueryGetPairMapRequest()
        request.pair_id = pair_id

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/PairMap",
            request,
            QueryGetPairMapResponse,
        )

    async def pair_map_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllPairMapResponse":

        request = QueryAllPairMapRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/PairMapAll",
            request,
            QueryAllPairMapResponse,
        )

    async def tokens(self, *, id: int = 0) -> "QueryGetTokensResponse":

        request = QueryGetTokensRequest()
        request.id = id

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/Tokens", request, QueryGetTokensResponse
        )

    async def tokens_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllTokensResponse":

        request = QueryAllTokensRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/TokensAll",
            request,
            QueryAllTokensResponse,
        )

    async def token_map(self, *, address: str = "") -> "QueryGetTokenMapResponse":

        request = QueryGetTokenMapRequest()
        request.address = address

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/TokenMap",
            request,
            QueryGetTokenMapResponse,
        )

    async def token_map_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllTokenMapResponse":

        request = QueryAllTokenMapRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/TokenMapAll",
            request,
            QueryAllTokenMapResponse,
        )

    async def shares(
        self, *, address: str = "", pair_id: str = "", tick_index: int = 0, fee: int = 0
    ) -> "QueryGetSharesResponse":

        request = QueryGetSharesRequest()
        request.address = address
        request.pair_id = pair_id
        request.tick_index = tick_index
        request.fee = fee

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/Shares", request, QueryGetSharesResponse
        )

    async def shares_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllSharesResponse":

        request = QueryAllSharesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/SharesAll",
            request,
            QueryAllSharesResponse,
        )

    async def fee_list(self, *, id: int = 0) -> "QueryGetFeeListResponse":

        request = QueryGetFeeListRequest()
        request.id = id

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/FeeList",
            request,
            QueryGetFeeListResponse,
        )

    async def fee_list_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllFeeListResponse":

        request = QueryAllFeeListRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/FeeListAll",
            request,
            QueryAllFeeListResponse,
        )

    async def edge_row(self, *, id: int = 0) -> "QueryGetEdgeRowResponse":

        request = QueryGetEdgeRowRequest()
        request.id = id

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/EdgeRow",
            request,
            QueryGetEdgeRowResponse,
        )

    async def edge_row_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllEdgeRowResponse":

        request = QueryAllEdgeRowRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/EdgeRowAll",
            request,
            QueryAllEdgeRowResponse,
        )

    async def adjancey_matrix(self, *, id: int = 0) -> "QueryGetAdjanceyMatrixResponse":

        request = QueryGetAdjanceyMatrixRequest()
        request.id = id

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/AdjanceyMatrix",
            request,
            QueryGetAdjanceyMatrixResponse,
        )

    async def adjancey_matrix_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllAdjanceyMatrixResponse":

        request = QueryAllAdjanceyMatrixRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/AdjanceyMatrixAll",
            request,
            QueryAllAdjanceyMatrixResponse,
        )

    async def limit_order_pool_user_share_map(
        self,
        *,
        pair_id: str = "",
        tick_index: int = 0,
        token: str = "",
        count: int = 0,
        address: str = ""
    ) -> "QueryGetLimitOrderPoolUserShareMapResponse":

        request = QueryGetLimitOrderPoolUserShareMapRequest()
        request.pair_id = pair_id
        request.tick_index = tick_index
        request.token = token
        request.count = count
        request.address = address

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolUserShareMap",
            request,
            QueryGetLimitOrderPoolUserShareMapResponse,
        )

    async def limit_order_pool_user_share_map_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllLimitOrderPoolUserShareMapResponse":

        request = QueryAllLimitOrderPoolUserShareMapRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolUserShareMapAll",
            request,
            QueryAllLimitOrderPoolUserShareMapResponse,
        )

    async def limit_order_pool_user_shares_withdrawn(
        self,
        *,
        pair_id: str = "",
        tick_index: int = 0,
        token: str = "",
        count: int = 0,
        address: str = ""
    ) -> "QueryGetLimitOrderPoolUserSharesWithdrawnResponse":

        request = QueryGetLimitOrderPoolUserSharesWithdrawnRequest()
        request.pair_id = pair_id
        request.tick_index = tick_index
        request.token = token
        request.count = count
        request.address = address

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolUserSharesWithdrawn",
            request,
            QueryGetLimitOrderPoolUserSharesWithdrawnResponse,
        )

    async def limit_order_pool_user_shares_withdrawn_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllLimitOrderPoolUserSharesWithdrawnResponse":

        request = QueryAllLimitOrderPoolUserSharesWithdrawnRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolUserSharesWithdrawnAll",
            request,
            QueryAllLimitOrderPoolUserSharesWithdrawnResponse,
        )

    async def limit_order_pool_total_shares_map(
        self, *, pair_id: str = "", tick_index: int = 0, token: str = "", count: int = 0
    ) -> "QueryGetLimitOrderPoolTotalSharesMapResponse":

        request = QueryGetLimitOrderPoolTotalSharesMapRequest()
        request.pair_id = pair_id
        request.tick_index = tick_index
        request.token = token
        request.count = count

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolTotalSharesMap",
            request,
            QueryGetLimitOrderPoolTotalSharesMapResponse,
        )

    async def limit_order_pool_total_shares_map_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllLimitOrderPoolTotalSharesMapResponse":

        request = QueryAllLimitOrderPoolTotalSharesMapRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolTotalSharesMapAll",
            request,
            QueryAllLimitOrderPoolTotalSharesMapResponse,
        )

    async def limit_order_pool_reserve_map(
        self, *, pair_id: str = "", tick_index: int = 0, token: str = "", count: int = 0
    ) -> "QueryGetLimitOrderPoolReserveMapResponse":

        request = QueryGetLimitOrderPoolReserveMapRequest()
        request.pair_id = pair_id
        request.tick_index = tick_index
        request.token = token
        request.count = count

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolReserveMap",
            request,
            QueryGetLimitOrderPoolReserveMapResponse,
        )

    async def limit_order_pool_reserve_map_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllLimitOrderPoolReserveMapResponse":

        request = QueryAllLimitOrderPoolReserveMapRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolReserveMapAll",
            request,
            QueryAllLimitOrderPoolReserveMapResponse,
        )

    async def limit_order_pool_fill_map(
        self, *, pair_id: str = "", tick_index: int = 0, token: str = "", count: int = 0
    ) -> "QueryGetLimitOrderPoolFillMapResponse":

        request = QueryGetLimitOrderPoolFillMapRequest()
        request.pair_id = pair_id
        request.tick_index = tick_index
        request.token = token
        request.count = count

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolFillMap",
            request,
            QueryGetLimitOrderPoolFillMapResponse,
        )

    async def limit_order_pool_fill_map_all(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QueryAllLimitOrderPoolFillMapResponse":

        request = QueryAllLimitOrderPoolFillMapRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolFillMapAll",
            request,
            QueryAllLimitOrderPoolFillMapResponse,
        )


class MsgBase(ServiceBase):
    async def deposit(
        self,
        creator: str,
        receiver: str,
        token_a: str,
        token_b: str,
        amounts_a: Optional[List[str]],
        amounts_b: Optional[List[str]],
        tick_indexes: Optional[List[int]],
        fee_indexes: Optional[List[int]],
    ) -> "MsgDepositResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def withdrawl(
        self,
        creator: str,
        receiver: str,
        token_a: str,
        token_b: str,
        shares_to_remove: Optional[List[str]],
        tick_indexes: Optional[List[int]],
        fee_indexes: Optional[List[int]],
    ) -> "MsgWithdrawlResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def swap(
        self,
        creator: str,
        receiver: str,
        token_a: str,
        token_b: str,
        amount_in: str,
        token_in: str,
        min_out: str,
    ) -> "MsgSwapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def place_limit_order(
        self,
        creator: str,
        receiver: str,
        token_a: str,
        token_b: str,
        tick_index: int,
        token_in: str,
        amount_in: str,
    ) -> "MsgPlaceLimitOrderResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def withdraw_filled_limit_order(
        self,
        creator: str,
        receiver: str,
        token_a: str,
        token_b: str,
        tick_index: int,
        key_token: str,
        key: int,
    ) -> "MsgWithdrawFilledLimitOrderResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel_limit_order(
        self,
        creator: str,
        receiver: str,
        token_a: str,
        token_b: str,
        tick_index: int,
        key_token: str,
        key: int,
        shares_out: str,
    ) -> "MsgCancelLimitOrderResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_deposit(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "creator": request.creator,
            "receiver": request.receiver,
            "token_a": request.token_a,
            "token_b": request.token_b,
            "amounts_a": request.amounts_a,
            "amounts_b": request.amounts_b,
            "tick_indexes": request.tick_indexes,
            "fee_indexes": request.fee_indexes,
        }

        response = await self.deposit(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_withdrawl(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "creator": request.creator,
            "receiver": request.receiver,
            "token_a": request.token_a,
            "token_b": request.token_b,
            "shares_to_remove": request.shares_to_remove,
            "tick_indexes": request.tick_indexes,
            "fee_indexes": request.fee_indexes,
        }

        response = await self.withdrawl(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_swap(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "creator": request.creator,
            "receiver": request.receiver,
            "token_a": request.token_a,
            "token_b": request.token_b,
            "amount_in": request.amount_in,
            "token_in": request.token_in,
            "min_out": request.min_out,
        }

        response = await self.swap(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_place_limit_order(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "creator": request.creator,
            "receiver": request.receiver,
            "token_a": request.token_a,
            "token_b": request.token_b,
            "tick_index": request.tick_index,
            "token_in": request.token_in,
            "amount_in": request.amount_in,
        }

        response = await self.place_limit_order(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_withdraw_filled_limit_order(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "creator": request.creator,
            "receiver": request.receiver,
            "token_a": request.token_a,
            "token_b": request.token_b,
            "tick_index": request.tick_index,
            "key_token": request.key_token,
            "key": request.key,
        }

        response = await self.withdraw_filled_limit_order(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_cancel_limit_order(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "creator": request.creator,
            "receiver": request.receiver,
            "token_a": request.token_a,
            "token_b": request.token_b,
            "tick_index": request.tick_index,
            "key_token": request.key_token,
            "key": request.key,
            "shares_out": request.shares_out,
        }

        response = await self.cancel_limit_order(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nicholasdotsol.duality.dex.Msg/Deposit": grpclib.const.Handler(
                self.__rpc_deposit,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDeposit,
                MsgDepositResponse,
            ),
            "/nicholasdotsol.duality.dex.Msg/Withdrawl": grpclib.const.Handler(
                self.__rpc_withdrawl,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgWithdrawl,
                MsgWithdrawlResponse,
            ),
            "/nicholasdotsol.duality.dex.Msg/Swap": grpclib.const.Handler(
                self.__rpc_swap,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSwap,
                MsgSwapResponse,
            ),
            "/nicholasdotsol.duality.dex.Msg/PlaceLimitOrder": grpclib.const.Handler(
                self.__rpc_place_limit_order,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgPlaceLimitOrder,
                MsgPlaceLimitOrderResponse,
            ),
            "/nicholasdotsol.duality.dex.Msg/WithdrawFilledLimitOrder": grpclib.const.Handler(
                self.__rpc_withdraw_filled_limit_order,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgWithdrawFilledLimitOrder,
                MsgWithdrawFilledLimitOrderResponse,
            ),
            "/nicholasdotsol.duality.dex.Msg/CancelLimitOrder": grpclib.const.Handler(
                self.__rpc_cancel_limit_order,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCancelLimitOrder,
                MsgCancelLimitOrderResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def params(self) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tick_map(
        self, tick_index: int, pair_id: str
    ) -> "QueryGetTickMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tick_map_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllTickMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pair_map(self, pair_id: str) -> "QueryGetPairMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pair_map_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllPairMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tokens(self, id: int) -> "QueryGetTokensResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def tokens_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllTokensResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def token_map(self, address: str) -> "QueryGetTokenMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def token_map_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllTokenMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def shares(
        self, address: str, pair_id: str, tick_index: int, fee: int
    ) -> "QueryGetSharesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def shares_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllSharesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fee_list(self, id: int) -> "QueryGetFeeListResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def fee_list_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllFeeListResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def edge_row(self, id: int) -> "QueryGetEdgeRowResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def edge_row_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllEdgeRowResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def adjancey_matrix(self, id: int) -> "QueryGetAdjanceyMatrixResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def adjancey_matrix_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllAdjanceyMatrixResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_user_share_map(
        self, pair_id: str, tick_index: int, token: str, count: int, address: str
    ) -> "QueryGetLimitOrderPoolUserShareMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_user_share_map_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllLimitOrderPoolUserShareMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_user_shares_withdrawn(
        self, pair_id: str, tick_index: int, token: str, count: int, address: str
    ) -> "QueryGetLimitOrderPoolUserSharesWithdrawnResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_user_shares_withdrawn_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllLimitOrderPoolUserSharesWithdrawnResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_total_shares_map(
        self, pair_id: str, tick_index: int, token: str, count: int
    ) -> "QueryGetLimitOrderPoolTotalSharesMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_total_shares_map_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllLimitOrderPoolTotalSharesMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_reserve_map(
        self, pair_id: str, tick_index: int, token: str, count: int
    ) -> "QueryGetLimitOrderPoolReserveMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_reserve_map_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllLimitOrderPoolReserveMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_fill_map(
        self, pair_id: str, tick_index: int, token: str, count: int
    ) -> "QueryGetLimitOrderPoolFillMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def limit_order_pool_fill_map_all(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QueryAllLimitOrderPoolFillMapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.params(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_tick_map(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "tick_index": request.tick_index,
            "pair_id": request.pair_id,
        }

        response = await self.tick_map(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_tick_map_all(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.tick_map_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pair_map(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pair_id": request.pair_id,
        }

        response = await self.pair_map(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pair_map_all(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.pair_map_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_tokens(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "id": request.id,
        }

        response = await self.tokens(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_tokens_all(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.tokens_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_token_map(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "address": request.address,
        }

        response = await self.token_map(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_token_map_all(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.token_map_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_shares(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "address": request.address,
            "pair_id": request.pair_id,
            "tick_index": request.tick_index,
            "fee": request.fee,
        }

        response = await self.shares(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_shares_all(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.shares_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_fee_list(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "id": request.id,
        }

        response = await self.fee_list(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_fee_list_all(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.fee_list_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_edge_row(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "id": request.id,
        }

        response = await self.edge_row(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_edge_row_all(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.edge_row_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_adjancey_matrix(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "id": request.id,
        }

        response = await self.adjancey_matrix(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_adjancey_matrix_all(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.adjancey_matrix_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_user_share_map(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pair_id": request.pair_id,
            "tick_index": request.tick_index,
            "token": request.token,
            "count": request.count,
            "address": request.address,
        }

        response = await self.limit_order_pool_user_share_map(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_user_share_map_all(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.limit_order_pool_user_share_map_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_user_shares_withdrawn(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pair_id": request.pair_id,
            "tick_index": request.tick_index,
            "token": request.token,
            "count": request.count,
            "address": request.address,
        }

        response = await self.limit_order_pool_user_shares_withdrawn(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_user_shares_withdrawn_all(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.limit_order_pool_user_shares_withdrawn_all(
            **request_kwargs
        )
        await stream.send_message(response)

    async def __rpc_limit_order_pool_total_shares_map(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pair_id": request.pair_id,
            "tick_index": request.tick_index,
            "token": request.token,
            "count": request.count,
        }

        response = await self.limit_order_pool_total_shares_map(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_total_shares_map_all(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.limit_order_pool_total_shares_map_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_reserve_map(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pair_id": request.pair_id,
            "tick_index": request.tick_index,
            "token": request.token,
            "count": request.count,
        }

        response = await self.limit_order_pool_reserve_map(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_reserve_map_all(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.limit_order_pool_reserve_map_all(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_fill_map(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pair_id": request.pair_id,
            "tick_index": request.tick_index,
            "token": request.token,
            "count": request.count,
        }

        response = await self.limit_order_pool_fill_map(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_limit_order_pool_fill_map_all(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.limit_order_pool_fill_map_all(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nicholasdotsol.duality.dex.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/TickMap": grpclib.const.Handler(
                self.__rpc_tick_map,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetTickMapRequest,
                QueryGetTickMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/TickMapAll": grpclib.const.Handler(
                self.__rpc_tick_map_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllTickMapRequest,
                QueryAllTickMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/PairMap": grpclib.const.Handler(
                self.__rpc_pair_map,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetPairMapRequest,
                QueryGetPairMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/PairMapAll": grpclib.const.Handler(
                self.__rpc_pair_map_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllPairMapRequest,
                QueryAllPairMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/Tokens": grpclib.const.Handler(
                self.__rpc_tokens,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetTokensRequest,
                QueryGetTokensResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/TokensAll": grpclib.const.Handler(
                self.__rpc_tokens_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllTokensRequest,
                QueryAllTokensResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/TokenMap": grpclib.const.Handler(
                self.__rpc_token_map,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetTokenMapRequest,
                QueryGetTokenMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/TokenMapAll": grpclib.const.Handler(
                self.__rpc_token_map_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllTokenMapRequest,
                QueryAllTokenMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/Shares": grpclib.const.Handler(
                self.__rpc_shares,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetSharesRequest,
                QueryGetSharesResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/SharesAll": grpclib.const.Handler(
                self.__rpc_shares_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllSharesRequest,
                QueryAllSharesResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/FeeList": grpclib.const.Handler(
                self.__rpc_fee_list,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetFeeListRequest,
                QueryGetFeeListResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/FeeListAll": grpclib.const.Handler(
                self.__rpc_fee_list_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllFeeListRequest,
                QueryAllFeeListResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/EdgeRow": grpclib.const.Handler(
                self.__rpc_edge_row,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetEdgeRowRequest,
                QueryGetEdgeRowResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/EdgeRowAll": grpclib.const.Handler(
                self.__rpc_edge_row_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllEdgeRowRequest,
                QueryAllEdgeRowResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/AdjanceyMatrix": grpclib.const.Handler(
                self.__rpc_adjancey_matrix,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetAdjanceyMatrixRequest,
                QueryGetAdjanceyMatrixResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/AdjanceyMatrixAll": grpclib.const.Handler(
                self.__rpc_adjancey_matrix_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllAdjanceyMatrixRequest,
                QueryAllAdjanceyMatrixResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolUserShareMap": grpclib.const.Handler(
                self.__rpc_limit_order_pool_user_share_map,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetLimitOrderPoolUserShareMapRequest,
                QueryGetLimitOrderPoolUserShareMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolUserShareMapAll": grpclib.const.Handler(
                self.__rpc_limit_order_pool_user_share_map_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllLimitOrderPoolUserShareMapRequest,
                QueryAllLimitOrderPoolUserShareMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolUserSharesWithdrawn": grpclib.const.Handler(
                self.__rpc_limit_order_pool_user_shares_withdrawn,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetLimitOrderPoolUserSharesWithdrawnRequest,
                QueryGetLimitOrderPoolUserSharesWithdrawnResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolUserSharesWithdrawnAll": grpclib.const.Handler(
                self.__rpc_limit_order_pool_user_shares_withdrawn_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllLimitOrderPoolUserSharesWithdrawnRequest,
                QueryAllLimitOrderPoolUserSharesWithdrawnResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolTotalSharesMap": grpclib.const.Handler(
                self.__rpc_limit_order_pool_total_shares_map,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetLimitOrderPoolTotalSharesMapRequest,
                QueryGetLimitOrderPoolTotalSharesMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolTotalSharesMapAll": grpclib.const.Handler(
                self.__rpc_limit_order_pool_total_shares_map_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllLimitOrderPoolTotalSharesMapRequest,
                QueryAllLimitOrderPoolTotalSharesMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolReserveMap": grpclib.const.Handler(
                self.__rpc_limit_order_pool_reserve_map,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetLimitOrderPoolReserveMapRequest,
                QueryGetLimitOrderPoolReserveMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolReserveMapAll": grpclib.const.Handler(
                self.__rpc_limit_order_pool_reserve_map_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllLimitOrderPoolReserveMapRequest,
                QueryAllLimitOrderPoolReserveMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolFillMap": grpclib.const.Handler(
                self.__rpc_limit_order_pool_fill_map,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGetLimitOrderPoolFillMapRequest,
                QueryGetLimitOrderPoolFillMapResponse,
            ),
            "/nicholasdotsol.duality.dex.Query/LimitOrderPoolFillMapAll": grpclib.const.Handler(
                self.__rpc_limit_order_pool_fill_map_all,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllLimitOrderPoolFillMapRequest,
                QueryAllLimitOrderPoolFillMapResponse,
            ),
        }


from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__
