# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osmosis/streamswap/v1/event.proto, osmosis/streamswap/v1/genesis.proto, osmosis/streamswap/v1/params.proto, osmosis/streamswap/v1/query.proto, osmosis/streamswap/v1/state.proto, osmosis/streamswap/v1/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params holds parameters for the streamswap module"""

    # fee charged when creating a new sale. The fee will go to the
    # sale_fee_recipient unless it is not defined (empty).
    sale_creation_fee: List[
        "___cosmos_base_v1_beta1__.Coin"
    ] = betterproto.message_field(1)
    # bech32 address of the fee recipient
    sale_creation_fee_recipient: str = betterproto.string_field(2)
    # minimum amount duration of time between the sale creation and the sale
    # start time.
    min_duration_until_start_time: timedelta = betterproto.message_field(3)
    # minimum duration for every new sale.
    min_sale_duration: timedelta = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class MsgCreateSale(betterproto.Message):
    # Sale creator and the account which provides token (token_out) to the sale.
    # When processing this message, token_out
    creator: str = betterproto.string_field(1)
    # token_in is a denom used to buy `token_out`. May be referred as a "quote
    # currency".
    token_in: str = betterproto.string_field(2)
    # token_out is a coin supply (denom + amount) to sell. May be referred as
    # "base currency". The whole supply will be transferred from the creator to
    # the module and will be sold during the sale.
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    # Maximum fee the creator is going to pay for creating a sale. The creator
    # will be charged params.SaleCreationFee. Transaction will fail if max_fee is
    # smaller than params.SaleCreationFee. If empty, the creator doesn't accept
    # any fee.
    max_fee: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)
    # start time when the token sale starts.
    start_time: datetime = betterproto.message_field(5)
    # duration time that the sale takes place over
    duration: timedelta = betterproto.message_field(6)
    # Recipient is the account which receives earned `token_in` from when the
    # sale is finalized. If not defined (empty) the creator account will be used.
    recipient: str = betterproto.string_field(7)
    # Name for the sale, max 40 characters, min 4. Required.
    name: str = betterproto.string_field(8)
    # URL with sale and project details. Can be a link a link to IPFS, hackmd,
    # project page, blog post... Max 120 characters. Must be valid agains Go
    # url.ParseRequestURI. Required.
    url: str = betterproto.string_field(9)


@dataclass(eq=False, repr=False)
class MsgCreateSaleResponse(betterproto.Message):
    sale_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class MsgSubscribe(betterproto.Message):
    # sender is an account address adding a deposit
    sender: str = betterproto.string_field(1)
    # ID of an existing sale.
    sale_id: int = betterproto.uint64_field(2)
    # number of sale.token_in staked by a user.
    amount: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MsgWithdraw(betterproto.Message):
    # sender is an account address subscribed to the sale_id
    sender: str = betterproto.string_field(1)
    # ID of a sale.
    sale_id: int = betterproto.uint64_field(2)
    # amount of tokens_in to withdraw. Must be at most the amount of not spent
    # tokens, unless set to null - then all remaining balance will be withdrawn.
    amount: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MsgExitSale(betterproto.Message):
    # sender is an account address exiting a sale
    sender: str = betterproto.string_field(1)
    # ID of an existing sale.
    sale_id: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class MsgExitSaleResponse(betterproto.Message):
    # Purchased amount of "out" tokens withdrawn to the user.
    purchased: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgFinalizeSale(betterproto.Message):
    # sender is an account signing the message and triggering the finalization.
    sender: str = betterproto.string_field(1)
    # ID of an existing sale.
    sale_id: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class MsgFinalizeSaleResponse(betterproto.Message):
    # Income amount of token_in sent to the sale recipient.
    income: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Sale(betterproto.Message):
    # Destination for the earned token_in
    treasury: str = betterproto.string_field(1)
    id: int = betterproto.uint64_field(2)
    # token_out is a token denom to be bootstraped. May be referred as base
    # currency, or a sale token.
    token_out: str = betterproto.string_field(3)
    # token_in is a token denom used to buy sale tokens (`token_out`). May be
    # referred as quote_currency or payment token.
    token_in: str = betterproto.string_field(4)
    # total number of `tokens_out` to be sold during the continuous sale.
    token_out_supply: str = betterproto.string_field(5)
    # start time when the token emission starts.
    start_time: datetime = betterproto.message_field(6)
    # end time when the token emission ends. Can't be bigger than start +
    # 139years (to avoid round overflow)
    end_time: datetime = betterproto.message_field(7)
    # Round number when the sale was last time updated.
    round: int = betterproto.int64_field(8)
    # Last round of the Sale;
    end_round: int = betterproto.int64_field(9)
    # amout of remaining token_out to sell
    out_remaining: str = betterproto.string_field(10)
    # amount of token_out sold
    out_sold: str = betterproto.string_field(11)
    # out token per share
    out_per_share: str = betterproto.string_field(12)
    # total amount of currently staked coins (token_in) but not spent coins.
    staked: str = betterproto.string_field(13)
    # total amount of earned coins (token_in)
    income: str = betterproto.string_field(14)
    # total amount of shares
    shares: str = betterproto.string_field(15)
    # Name for the sale.
    name: str = betterproto.string_field(20)
    # URL with sale and project details.
    url: str = betterproto.string_field(21)


@dataclass(eq=False, repr=False)
class UserPosition(betterproto.Message):
    """UserPosition represents user account in a sale"""

    shares: str = betterproto.string_field(1)
    # total number of currently staked tokens
    staked: str = betterproto.string_field(2)
    # last token/share ratio
    out_per_share: str = betterproto.string_field(3)
    # amount of token_in spent
    spent: str = betterproto.string_field(4)
    # Amount of accumulated, not withdrawn, purchased tokens (token_out)
    purchased: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the streamswap module's genesis state."""

    sales: List["Sale"] = betterproto.message_field(1)
    user_positions: List["UserPositionKv"] = betterproto.message_field(2)
    next_sale_id: int = betterproto.uint64_field(3)
    params: "Params" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class UserPositionKv(betterproto.Message):
    """
    UserPositionKV is a record in genesis representing acc_address user
    position of a sale_id sale.
    """

    # user account address
    acc_address: str = betterproto.string_field(1)
    sale_id: int = betterproto.uint64_field(2)
    user_position: "UserPosition" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class EventCreateSale(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    creator: str = betterproto.string_field(2)
    token_in: str = betterproto.string_field(3)
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class EventSubscribe(betterproto.Message):
    sender: str = betterproto.string_field(1)
    sale_id: int = betterproto.uint64_field(2)
    amount: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class EventWithdraw(betterproto.Message):
    sender: str = betterproto.string_field(1)
    sale_id: int = betterproto.uint64_field(2)
    # amount of staked token_in withdrawn by user.
    amount: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class EventExit(betterproto.Message):
    sender: str = betterproto.string_field(1)
    sale_id: int = betterproto.uint64_field(2)
    # amount of purchased token_out sent to the user
    purchased: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class EventFinalizeSale(betterproto.Message):
    sale_id: int = betterproto.uint64_field(1)
    # amount of earned tokens_in
    income: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class QuerySales(betterproto.Message):
    # pagination defines an pagination for the request.
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class QuerySalesResponse(betterproto.Message):
    sales: List["Sale"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QuerySale(betterproto.Message):
    """Request type for Query/Sale"""

    # Sale ID
    sale_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QuerySaleResponse(betterproto.Message):
    sale: "Sale" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryUserPosition(betterproto.Message):
    """Request type for Query/Sale"""

    # ID of the Sale
    sale_id: int = betterproto.uint64_field(1)
    # user account address
    user: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryUserPositionResponse(betterproto.Message):
    user_position: "UserPosition" = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    async def create_sale(
        self,
        *,
        creator: str = "",
        token_in: str = "",
        token_out: "___cosmos_base_v1_beta1__.Coin" = None,
        max_fee: Optional[List["___cosmos_base_v1_beta1__.Coin"]] = None,
        start_time: datetime = None,
        duration: timedelta = None,
        recipient: str = "",
        name: str = "",
        url: str = ""
    ) -> "MsgCreateSaleResponse":
        max_fee = max_fee or []

        request = MsgCreateSale()
        request.creator = creator
        request.token_in = token_in
        if token_out is not None:
            request.token_out = token_out
        if max_fee is not None:
            request.max_fee = max_fee
        if start_time is not None:
            request.start_time = start_time
        if duration is not None:
            request.duration = duration
        request.recipient = recipient
        request.name = name
        request.url = url

        return await self._unary_unary(
            "/osmosis.streamswap.v1.Msg/CreateSale", request, MsgCreateSaleResponse
        )

    async def subscribe(
        self, *, sender: str = "", sale_id: int = 0, amount: str = ""
    ) -> "betterproto_lib_google_protobuf.Empty":

        request = MsgSubscribe()
        request.sender = sender
        request.sale_id = sale_id
        request.amount = amount

        return await self._unary_unary(
            "/osmosis.streamswap.v1.Msg/Subscribe",
            request,
            betterproto_lib_google_protobuf.Empty,
        )

    async def withdraw(
        self, *, sender: str = "", sale_id: int = 0, amount: str = ""
    ) -> "betterproto_lib_google_protobuf.Empty":

        request = MsgWithdraw()
        request.sender = sender
        request.sale_id = sale_id
        request.amount = amount

        return await self._unary_unary(
            "/osmosis.streamswap.v1.Msg/Withdraw",
            request,
            betterproto_lib_google_protobuf.Empty,
        )

    async def exit_sale(
        self, *, sender: str = "", sale_id: int = 0
    ) -> "MsgExitSaleResponse":

        request = MsgExitSale()
        request.sender = sender
        request.sale_id = sale_id

        return await self._unary_unary(
            "/osmosis.streamswap.v1.Msg/ExitSale", request, MsgExitSaleResponse
        )

    async def finalize_sale(
        self, *, sender: str = "", sale_id: int = 0
    ) -> "MsgFinalizeSaleResponse":

        request = MsgFinalizeSale()
        request.sender = sender
        request.sale_id = sale_id

        return await self._unary_unary(
            "/osmosis.streamswap.v1.Msg/FinalizeSale", request, MsgFinalizeSaleResponse
        )


class QueryStub(betterproto.ServiceStub):
    async def sales(
        self, *, pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "QuerySalesResponse":

        request = QuerySales()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.streamswap.v1.Query/Sales", request, QuerySalesResponse
        )

    async def sale(self, *, sale_id: int = 0) -> "QuerySaleResponse":

        request = QuerySale()
        request.sale_id = sale_id

        return await self._unary_unary(
            "/osmosis.streamswap.v1.Query/Sale", request, QuerySaleResponse
        )

    async def user_position(
        self, *, sale_id: int = 0, user: str = ""
    ) -> "QueryUserPositionResponse":

        request = QueryUserPosition()
        request.sale_id = sale_id
        request.user = user

        return await self._unary_unary(
            "/osmosis.streamswap.v1.Query/UserPosition",
            request,
            QueryUserPositionResponse,
        )


class MsgBase(ServiceBase):
    async def create_sale(
        self,
        creator: str,
        token_in: str,
        token_out: "___cosmos_base_v1_beta1__.Coin",
        max_fee: Optional[List["___cosmos_base_v1_beta1__.Coin"]],
        start_time: datetime,
        duration: timedelta,
        recipient: str,
        name: str,
        url: str,
    ) -> "MsgCreateSaleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, sender: str, sale_id: int, amount: str
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def withdraw(
        self, sender: str, sale_id: int, amount: str
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exit_sale(self, sender: str, sale_id: int) -> "MsgExitSaleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def finalize_sale(
        self, sender: str, sale_id: int
    ) -> "MsgFinalizeSaleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_sale(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "creator": request.creator,
            "token_in": request.token_in,
            "token_out": request.token_out,
            "max_fee": request.max_fee,
            "start_time": request.start_time,
            "duration": request.duration,
            "recipient": request.recipient,
            "name": request.name,
            "url": request.url,
        }

        response = await self.create_sale(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_subscribe(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "sale_id": request.sale_id,
            "amount": request.amount,
        }

        response = await self.subscribe(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_withdraw(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "sale_id": request.sale_id,
            "amount": request.amount,
        }

        response = await self.withdraw(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_exit_sale(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "sale_id": request.sale_id,
        }

        response = await self.exit_sale(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_finalize_sale(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sender": request.sender,
            "sale_id": request.sale_id,
        }

        response = await self.finalize_sale(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.streamswap.v1.Msg/CreateSale": grpclib.const.Handler(
                self.__rpc_create_sale,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateSale,
                MsgCreateSaleResponse,
            ),
            "/osmosis.streamswap.v1.Msg/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSubscribe,
                betterproto_lib_google_protobuf.Empty,
            ),
            "/osmosis.streamswap.v1.Msg/Withdraw": grpclib.const.Handler(
                self.__rpc_withdraw,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgWithdraw,
                betterproto_lib_google_protobuf.Empty,
            ),
            "/osmosis.streamswap.v1.Msg/ExitSale": grpclib.const.Handler(
                self.__rpc_exit_sale,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExitSale,
                MsgExitSaleResponse,
            ),
            "/osmosis.streamswap.v1.Msg/FinalizeSale": grpclib.const.Handler(
                self.__rpc_finalize_sale,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgFinalizeSale,
                MsgFinalizeSaleResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def sales(
        self, pagination: "___cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "QuerySalesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def sale(self, sale_id: int) -> "QuerySaleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def user_position(
        self, sale_id: int, user: str
    ) -> "QueryUserPositionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_sales(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.sales(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_sale(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sale_id": request.sale_id,
        }

        response = await self.sale(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_user_position(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "sale_id": request.sale_id,
            "user": request.user,
        }

        response = await self.user_position(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.streamswap.v1.Query/Sales": grpclib.const.Handler(
                self.__rpc_sales,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySales,
                QuerySalesResponse,
            ),
            "/osmosis.streamswap.v1.Query/Sale": grpclib.const.Handler(
                self.__rpc_sale,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySale,
                QuerySaleResponse,
            ),
            "/osmosis.streamswap.v1.Query/UserPosition": grpclib.const.Handler(
                self.__rpc_user_position,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryUserPosition,
                QueryUserPositionResponse,
            ),
        }


from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
