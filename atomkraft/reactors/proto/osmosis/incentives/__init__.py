# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osmosis/incentives/gauge.proto, osmosis/incentives/genesis.proto, osmosis/incentives/params.proto, osmosis/incentives/query.proto, osmosis/incentives/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params holds parameters for the incentives module"""

    # distr_epoch_identifier is what epoch type distribution will be triggered by
    # (day, week, etc.)
    distr_epoch_identifier: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Gauge(betterproto.Message):
    """
    Gauge is an object that stores and distributes yields to recipients who
    satisfy certain conditions. Currently gauges support conditions around the
    duration for which a given denom is locked.
    """

    # id is the unique ID of a Gauge
    id: int = betterproto.uint64_field(1)
    # is_perpetual is a flag to show if it's a perpetual or non-perpetual gauge
    # Non-perpetual gauges distribute their tokens equally per epoch while the
    # gauge is in the active period. Perpetual gauges distribute all their tokens
    # at a single time and only distribute their tokens again once the gauge is
    # refilled, Intended for use with incentives that get refilled daily.
    is_perpetual: bool = betterproto.bool_field(2)
    # distribute_to is where the gauge rewards are distributed to. This is
    # queried via lock duration or by timestamp
    distribute_to: "_lockup__.QueryCondition" = betterproto.message_field(3)
    # coins is the total amount of coins that have been in the gauge Can
    # distribute multiple coin denoms
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)
    # start_time is the distribution start time
    start_time: datetime = betterproto.message_field(5)
    # num_epochs_paid_over is the number of total epochs distribution will be
    # completed over
    num_epochs_paid_over: int = betterproto.uint64_field(6)
    # filled_epochs is the number of epochs distribution has been completed on
    # already
    filled_epochs: int = betterproto.uint64_field(7)
    # distributed_coins are coins that have been distributed already
    distributed_coins: List[
        "__cosmos_base_v1_beta1__.Coin"
    ] = betterproto.message_field(8)


@dataclass(eq=False, repr=False)
class LockableDurationsInfo(betterproto.Message):
    # List of incentivised durations that gauges will pay out to
    lockable_durations: List[timedelta] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class MsgCreateGauge(betterproto.Message):
    """MsgCreateGauge creates a gague to distribute rewards to users"""

    # is_perpetual shows if it's a perpetual or non-perpetual gauge Non-perpetual
    # gauges distribute their tokens equally per epoch while the gauge is in the
    # active period. Perpetual gauges distribute all their tokens at a single
    # time and only distribute their tokens again once the gauge is refilled
    is_perpetual: bool = betterproto.bool_field(1)
    # owner is the address of gauge creator
    owner: str = betterproto.string_field(2)
    # distribute_to show which lock the gauge should distribute to by time
    # duration or by timestamp
    distribute_to: "_lockup__.QueryCondition" = betterproto.message_field(3)
    # coins are coin(s) to be distributed by the gauge
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)
    # start_time is the distribution start time
    start_time: datetime = betterproto.message_field(5)
    # num_epochs_paid_over is the number of epochs distribution will be completed
    # over
    num_epochs_paid_over: int = betterproto.uint64_field(6)


@dataclass(eq=False, repr=False)
class MsgCreateGaugeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgAddToGauge(betterproto.Message):
    """MsgAddToGauge adds coins to a previously created gauge"""

    # owner is the gauge owner's address
    owner: str = betterproto.string_field(1)
    # gauge_id is the ID of gauge that rewards are getting added to
    gauge_id: int = betterproto.uint64_field(2)
    # rewards are the coin(s) to add to gauge
    rewards: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgAddToGaugeResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """
    GenesisState defines the incentives module's various parameters when first
    initialized
    """

    # params are all the parameters of the module
    params: "Params" = betterproto.message_field(1)
    # gauges are all gauges that should exist at genesis
    gauges: List["Gauge"] = betterproto.message_field(2)
    # lockable_durations are all lockup durations that gauges can be locked for
    # in order to recieve incentives
    lockable_durations: List[timedelta] = betterproto.message_field(3)
    # last_gauge_id is what the gauge number will increment from when creating
    # the next gauge after genesis
    last_gauge_id: int = betterproto.uint64_field(4)


@dataclass(eq=False, repr=False)
class ModuleToDistributeCoinsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ModuleToDistributeCoinsResponse(betterproto.Message):
    # Coins that have yet to be distributed
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ModuleDistributedCoinsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ModuleDistributedCoinsResponse(betterproto.Message):
    # Coins that have been distributed already
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GaugeByIdRequest(betterproto.Message):
    # Gague ID being queried
    id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class GaugeByIdResponse(betterproto.Message):
    # Gauge that corresponds to provided gague ID
    gauge: "Gauge" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GaugesRequest(betterproto.Message):
    # Pagination defines pagination for the request
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class GaugesResponse(betterproto.Message):
    # Upcoming and active gauges
    data: List["Gauge"] = betterproto.message_field(1)
    # Pagination defines pagination for the response
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class ActiveGaugesRequest(betterproto.Message):
    # Pagination defines pagination for the request
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class ActiveGaugesResponse(betterproto.Message):
    # Active gagues only
    data: List["Gauge"] = betterproto.message_field(1)
    # Pagination defines pagination for the response
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class ActiveGaugesPerDenomRequest(betterproto.Message):
    # Desired denom when querying active gagues
    denom: str = betterproto.string_field(1)
    # Pagination defines pagination for the request
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class ActiveGaugesPerDenomResponse(betterproto.Message):
    # Active gagues that match denom in query
    data: List["Gauge"] = betterproto.message_field(1)
    # Pagination defines pagination for the response
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class UpcomingGaugesRequest(betterproto.Message):
    # Pagination defines pagination for the request
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class UpcomingGaugesResponse(betterproto.Message):
    # Gauges whose distribution is upcoming
    data: List["Gauge"] = betterproto.message_field(1)
    # Pagination defines pagination for the response
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class UpcomingGaugesPerDenomRequest(betterproto.Message):
    # Filter for upcoming gagues that match specific denom
    denom: str = betterproto.string_field(1)
    # Pagination defines pagination for the request
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class UpcomingGaugesPerDenomResponse(betterproto.Message):
    # Upcoming gagues that match denom in query
    upcoming_gauges: List["Gauge"] = betterproto.message_field(1)
    # Pagination defines pagination for the response
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class RewardsEstRequest(betterproto.Message):
    # Address that is being queried for future estimated rewards
    owner: str = betterproto.string_field(1)
    # Lock IDs included in future reward estimation
    lock_ids: List[int] = betterproto.uint64_field(2)
    # Upper time limit of reward estimation Lower limit is current epoch
    end_epoch: int = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class RewardsEstResponse(betterproto.Message):
    # Estimated coin rewards that will be recieved at provided address from
    # specified locks between current time and end epoch
    coins: List["__cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryLockableDurationsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryLockableDurationsResponse(betterproto.Message):
    # Time durations that users can lock coins for in order to recieve rewards
    lockable_durations: List[timedelta] = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    async def create_gauge(
        self,
        *,
        is_perpetual: bool = False,
        owner: str = "",
        distribute_to: "_lockup__.QueryCondition" = None,
        coins: Optional[List["__cosmos_base_v1_beta1__.Coin"]] = None,
        start_time: datetime = None,
        num_epochs_paid_over: int = 0
    ) -> "MsgCreateGaugeResponse":
        coins = coins or []

        request = MsgCreateGauge()
        request.is_perpetual = is_perpetual
        request.owner = owner
        if distribute_to is not None:
            request.distribute_to = distribute_to
        if coins is not None:
            request.coins = coins
        if start_time is not None:
            request.start_time = start_time
        request.num_epochs_paid_over = num_epochs_paid_over

        return await self._unary_unary(
            "/osmosis.incentives.Msg/CreateGauge", request, MsgCreateGaugeResponse
        )

    async def add_to_gauge(
        self,
        *,
        owner: str = "",
        gauge_id: int = 0,
        rewards: Optional[List["__cosmos_base_v1_beta1__.Coin"]] = None
    ) -> "MsgAddToGaugeResponse":
        rewards = rewards or []

        request = MsgAddToGauge()
        request.owner = owner
        request.gauge_id = gauge_id
        if rewards is not None:
            request.rewards = rewards

        return await self._unary_unary(
            "/osmosis.incentives.Msg/AddToGauge", request, MsgAddToGaugeResponse
        )


class QueryStub(betterproto.ServiceStub):
    async def module_to_distribute_coins(self) -> "ModuleToDistributeCoinsResponse":

        request = ModuleToDistributeCoinsRequest()

        return await self._unary_unary(
            "/osmosis.incentives.Query/ModuleToDistributeCoins",
            request,
            ModuleToDistributeCoinsResponse,
        )

    async def module_distributed_coins(self) -> "ModuleDistributedCoinsResponse":

        request = ModuleDistributedCoinsRequest()

        return await self._unary_unary(
            "/osmosis.incentives.Query/ModuleDistributedCoins",
            request,
            ModuleDistributedCoinsResponse,
        )

    async def gauge_by_id(self) -> "GaugeByIdResponse":

        request = GaugeByIdRequest()

        return await self._unary_unary(
            "/osmosis.incentives.Query/GaugeByID", request, GaugeByIdResponse
        )

    async def gauges(
        self, *, pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "GaugesResponse":

        request = GaugesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.incentives.Query/Gauges", request, GaugesResponse
        )

    async def active_gauges(
        self, *, pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "ActiveGaugesResponse":

        request = ActiveGaugesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.incentives.Query/ActiveGauges", request, ActiveGaugesResponse
        )

    async def active_gauges_per_denom(
        self,
        *,
        denom: str = "",
        pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "ActiveGaugesPerDenomResponse":

        request = ActiveGaugesPerDenomRequest()
        request.denom = denom
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.incentives.Query/ActiveGaugesPerDenom",
            request,
            ActiveGaugesPerDenomResponse,
        )

    async def upcoming_gauges(
        self, *, pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "UpcomingGaugesResponse":

        request = UpcomingGaugesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.incentives.Query/UpcomingGauges", request, UpcomingGaugesResponse
        )

    async def upcoming_gauges_per_denom(
        self,
        *,
        denom: str = "",
        pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = None
    ) -> "UpcomingGaugesPerDenomResponse":

        request = UpcomingGaugesPerDenomRequest()
        request.denom = denom
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/osmosis.incentives.Query/UpcomingGaugesPerDenom",
            request,
            UpcomingGaugesPerDenomResponse,
        )

    async def rewards_est(
        self,
        *,
        owner: str = "",
        lock_ids: Optional[List[int]] = None,
        end_epoch: int = 0
    ) -> "RewardsEstResponse":
        lock_ids = lock_ids or []

        request = RewardsEstRequest()
        request.owner = owner
        request.lock_ids = lock_ids
        request.end_epoch = end_epoch

        return await self._unary_unary(
            "/osmosis.incentives.Query/RewardsEst", request, RewardsEstResponse
        )

    async def lockable_durations(self) -> "QueryLockableDurationsResponse":

        request = QueryLockableDurationsRequest()

        return await self._unary_unary(
            "/osmosis.incentives.Query/LockableDurations",
            request,
            QueryLockableDurationsResponse,
        )


class MsgBase(ServiceBase):
    async def create_gauge(
        self,
        is_perpetual: bool,
        owner: str,
        distribute_to: "_lockup__.QueryCondition",
        coins: Optional[List["__cosmos_base_v1_beta1__.Coin"]],
        start_time: datetime,
        num_epochs_paid_over: int,
    ) -> "MsgCreateGaugeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_to_gauge(
        self,
        owner: str,
        gauge_id: int,
        rewards: Optional[List["__cosmos_base_v1_beta1__.Coin"]],
    ) -> "MsgAddToGaugeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_gauge(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "is_perpetual": request.is_perpetual,
            "owner": request.owner,
            "distribute_to": request.distribute_to,
            "coins": request.coins,
            "start_time": request.start_time,
            "num_epochs_paid_over": request.num_epochs_paid_over,
        }

        response = await self.create_gauge(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_add_to_gauge(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "owner": request.owner,
            "gauge_id": request.gauge_id,
            "rewards": request.rewards,
        }

        response = await self.add_to_gauge(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.incentives.Msg/CreateGauge": grpclib.const.Handler(
                self.__rpc_create_gauge,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGauge,
                MsgCreateGaugeResponse,
            ),
            "/osmosis.incentives.Msg/AddToGauge": grpclib.const.Handler(
                self.__rpc_add_to_gauge,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgAddToGauge,
                MsgAddToGaugeResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def module_to_distribute_coins(self) -> "ModuleToDistributeCoinsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def module_distributed_coins(self) -> "ModuleDistributedCoinsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def gauge_by_id(self) -> "GaugeByIdResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def gauges(
        self, pagination: "__cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "GaugesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def active_gauges(
        self, pagination: "__cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "ActiveGaugesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def active_gauges_per_denom(
        self, denom: str, pagination: "__cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "ActiveGaugesPerDenomResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def upcoming_gauges(
        self, pagination: "__cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "UpcomingGaugesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def upcoming_gauges_per_denom(
        self, denom: str, pagination: "__cosmos_base_query_v1_beta1__.PageRequest"
    ) -> "UpcomingGaugesPerDenomResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def rewards_est(
        self, owner: str, lock_ids: Optional[List[int]], end_epoch: int
    ) -> "RewardsEstResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def lockable_durations(self) -> "QueryLockableDurationsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_module_to_distribute_coins(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.module_to_distribute_coins(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_module_distributed_coins(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.module_distributed_coins(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_gauge_by_id(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.gauge_by_id(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_gauges(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.gauges(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_active_gauges(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.active_gauges(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_active_gauges_per_denom(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "denom": request.denom,
            "pagination": request.pagination,
        }

        response = await self.active_gauges_per_denom(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_upcoming_gauges(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pagination": request.pagination,
        }

        response = await self.upcoming_gauges(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_upcoming_gauges_per_denom(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "denom": request.denom,
            "pagination": request.pagination,
        }

        response = await self.upcoming_gauges_per_denom(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_rewards_est(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "owner": request.owner,
            "lock_ids": request.lock_ids,
            "end_epoch": request.end_epoch,
        }

        response = await self.rewards_est(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_lockable_durations(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.lockable_durations(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.incentives.Query/ModuleToDistributeCoins": grpclib.const.Handler(
                self.__rpc_module_to_distribute_coins,
                grpclib.const.Cardinality.UNARY_UNARY,
                ModuleToDistributeCoinsRequest,
                ModuleToDistributeCoinsResponse,
            ),
            "/osmosis.incentives.Query/ModuleDistributedCoins": grpclib.const.Handler(
                self.__rpc_module_distributed_coins,
                grpclib.const.Cardinality.UNARY_UNARY,
                ModuleDistributedCoinsRequest,
                ModuleDistributedCoinsResponse,
            ),
            "/osmosis.incentives.Query/GaugeByID": grpclib.const.Handler(
                self.__rpc_gauge_by_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                GaugeByIdRequest,
                GaugeByIdResponse,
            ),
            "/osmosis.incentives.Query/Gauges": grpclib.const.Handler(
                self.__rpc_gauges,
                grpclib.const.Cardinality.UNARY_UNARY,
                GaugesRequest,
                GaugesResponse,
            ),
            "/osmosis.incentives.Query/ActiveGauges": grpclib.const.Handler(
                self.__rpc_active_gauges,
                grpclib.const.Cardinality.UNARY_UNARY,
                ActiveGaugesRequest,
                ActiveGaugesResponse,
            ),
            "/osmosis.incentives.Query/ActiveGaugesPerDenom": grpclib.const.Handler(
                self.__rpc_active_gauges_per_denom,
                grpclib.const.Cardinality.UNARY_UNARY,
                ActiveGaugesPerDenomRequest,
                ActiveGaugesPerDenomResponse,
            ),
            "/osmosis.incentives.Query/UpcomingGauges": grpclib.const.Handler(
                self.__rpc_upcoming_gauges,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpcomingGaugesRequest,
                UpcomingGaugesResponse,
            ),
            "/osmosis.incentives.Query/UpcomingGaugesPerDenom": grpclib.const.Handler(
                self.__rpc_upcoming_gauges_per_denom,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpcomingGaugesPerDenomRequest,
                UpcomingGaugesPerDenomResponse,
            ),
            "/osmosis.incentives.Query/RewardsEst": grpclib.const.Handler(
                self.__rpc_rewards_est,
                grpclib.const.Cardinality.UNARY_UNARY,
                RewardsEstRequest,
                RewardsEstResponse,
            ),
            "/osmosis.incentives.Query/LockableDurations": grpclib.const.Handler(
                self.__rpc_lockable_durations,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLockableDurationsRequest,
                QueryLockableDurationsResponse,
            ),
        }


from .. import lockup as _lockup__
from ...cosmos.base import v1beta1 as __cosmos_base_v1_beta1__
from ...cosmos.base.query import v1beta1 as __cosmos_base_query_v1_beta1__
