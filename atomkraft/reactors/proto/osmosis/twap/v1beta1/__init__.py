# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: osmosis/twap/v1beta1/genesis.proto, osmosis/twap/v1beta1/query.proto, osmosis/twap/v1beta1/twap_record.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


@dataclass(eq=False, repr=False)
class TwapRecord(betterproto.Message):
    """
    A TWAP record should be indexed in state by pool_id, (asset pair),
    timestamp The asset pair assets should be lexicographically sorted.
    Technically (pool_id, asset_0_denom, asset_1_denom, height) do not need to
    appear in the struct however we view this as the wrong performance tradeoff
    given SDK today. Would rather we optimize for readability and correctness,
    than an optimal state storage format. The system bottleneck is elsewhere
    for now.
    """

    pool_id: int = betterproto.uint64_field(1)
    # Lexicographically smaller denom of the pair
    asset0_denom: str = betterproto.string_field(2)
    # Lexicographically larger denom of the pair
    asset1_denom: str = betterproto.string_field(3)
    # height this record corresponds to, for debugging purposes
    height: int = betterproto.int64_field(4)
    # This field should only exist until we have a global registry in the state
    # machine, mapping prior block heights within {TIME RANGE} to times.
    time: datetime = betterproto.message_field(5)
    # We store the last spot prices in the struct, so that we can interpolate
    # accumulator values for times between when accumulator records are stored.
    p0_last_spot_price: str = betterproto.string_field(6)
    p1_last_spot_price: str = betterproto.string_field(7)
    p0_arithmetic_twap_accumulator: str = betterproto.string_field(8)
    p1_arithmetic_twap_accumulator: str = betterproto.string_field(9)
    # This field contains the time in which the last spot price error occured. It
    # is used to alert the caller if they are getting a potentially erroneous
    # TWAP, due to an unforeseen underlying error.
    last_error_time: datetime = betterproto.message_field(11)


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params holds parameters for the twap module"""

    prune_epoch_identifier: str = betterproto.string_field(1)
    record_history_keep_period: timedelta = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the twap module's genesis state."""

    # twaps is the collection of all twap records.
    twaps: List["TwapRecord"] = betterproto.message_field(1)
    # params is the container of twap parameters.
    params: "Params" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ArithmeticTwapRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)
    base_asset: str = betterproto.string_field(2)
    quote_asset: str = betterproto.string_field(3)
    start_time: datetime = betterproto.message_field(4)
    end_time: datetime = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class ArithmeticTwapResponse(betterproto.Message):
    arithmetic_twap: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ArithmeticTwapToNowRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)
    base_asset: str = betterproto.string_field(2)
    quote_asset: str = betterproto.string_field(3)
    start_time: datetime = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class ArithmeticTwapToNowResponse(betterproto.Message):
    arithmetic_twap: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ParamsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ParamsResponse(betterproto.Message):
    params: "Params" = betterproto.message_field(1)


class QueryStub(betterproto.ServiceStub):
    async def params(self) -> "ParamsResponse":

        request = ParamsRequest()

        return await self._unary_unary(
            "/osmosis.twap.v1beta1.Query/Params", request, ParamsResponse
        )

    async def arithmetic_twap(
        self,
        *,
        pool_id: int = 0,
        base_asset: str = "",
        quote_asset: str = "",
        start_time: datetime = None,
        end_time: datetime = None
    ) -> "ArithmeticTwapResponse":

        request = ArithmeticTwapRequest()
        request.pool_id = pool_id
        request.base_asset = base_asset
        request.quote_asset = quote_asset
        if start_time is not None:
            request.start_time = start_time
        if end_time is not None:
            request.end_time = end_time

        return await self._unary_unary(
            "/osmosis.twap.v1beta1.Query/ArithmeticTwap",
            request,
            ArithmeticTwapResponse,
        )

    async def arithmetic_twap_to_now(
        self,
        *,
        pool_id: int = 0,
        base_asset: str = "",
        quote_asset: str = "",
        start_time: datetime = None
    ) -> "ArithmeticTwapToNowResponse":

        request = ArithmeticTwapToNowRequest()
        request.pool_id = pool_id
        request.base_asset = base_asset
        request.quote_asset = quote_asset
        if start_time is not None:
            request.start_time = start_time

        return await self._unary_unary(
            "/osmosis.twap.v1beta1.Query/ArithmeticTwapToNow",
            request,
            ArithmeticTwapToNowResponse,
        )


class QueryBase(ServiceBase):
    async def params(self) -> "ParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def arithmetic_twap(
        self,
        pool_id: int,
        base_asset: str,
        quote_asset: str,
        start_time: datetime,
        end_time: datetime,
    ) -> "ArithmeticTwapResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def arithmetic_twap_to_now(
        self, pool_id: int, base_asset: str, quote_asset: str, start_time: datetime
    ) -> "ArithmeticTwapToNowResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.params(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_arithmetic_twap(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
            "base_asset": request.base_asset,
            "quote_asset": request.quote_asset,
            "start_time": request.start_time,
            "end_time": request.end_time,
        }

        response = await self.arithmetic_twap(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_arithmetic_twap_to_now(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "pool_id": request.pool_id,
            "base_asset": request.base_asset,
            "quote_asset": request.quote_asset,
            "start_time": request.start_time,
        }

        response = await self.arithmetic_twap_to_now(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/osmosis.twap.v1beta1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                ParamsRequest,
                ParamsResponse,
            ),
            "/osmosis.twap.v1beta1.Query/ArithmeticTwap": grpclib.const.Handler(
                self.__rpc_arithmetic_twap,
                grpclib.const.Cardinality.UNARY_UNARY,
                ArithmeticTwapRequest,
                ArithmeticTwapResponse,
            ),
            "/osmosis.twap.v1beta1.Query/ArithmeticTwapToNow": grpclib.const.Handler(
                self.__rpc_arithmetic_twap_to_now,
                grpclib.const.Cardinality.UNARY_UNARY,
                ArithmeticTwapToNowRequest,
                ArithmeticTwapToNowResponse,
            ),
        }
